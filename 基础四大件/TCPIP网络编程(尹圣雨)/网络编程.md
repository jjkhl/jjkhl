<h1 align='center'>TCP/IP</h1>

[解决c++socket报错](https://blog.csdn.net/weixin_39591031/article/details/115222662)：手动编译文件，在编译命令后添加一个参数-lwsock32

## 网络编程与套接字

### 网络编程初始格式

头文件：`winsock2.h`

套接字是网络数据传输用的软件设备，还可以表示两台计算机之间的网络连接。

网络编程中接收连接请求的套接字创建过程：

* 调用socket函数创建套接字：`SOCKET socket()`
* 调用bind函数分配IP地址和端口号
* 调用listen函数转换为可接收请求状态
* 调用accept函数受理连接请求

### 文件打开方式

头文件：`unistd.h`——write、close、read函数、`fcntl.h`——open函数

> windows下`unistd.h`报错解决方法：新建`unistd.h`文件
>
> ```c++
> #ifndef _UNISTD_H
> #define _UNISTD_H
> #include <io.h>
> #include <process.h>
> #endif /* _UNISTD_H */
> ```

#### open函数

`fd=open("data.txt", O_CREAT|O_WRONLY|O_TRUNC);`

成功返回文件描述符，失败返回-1

| 打开模式 | 含义                     |
| -------- | ------------------------ |
| O_CREAT  | 必要时创建文件           |
| O_TRUNC  | 删除全部现有数据         |
| O_APPEND | 维持现有数据，保存在后面 |
| O_RDONLY | 只读打开                 |
| O_WRONLY | 只写打开                 |
| O_RDWR   | 读写打开                 |

#### close函数

`a=close(fd);`

成功返回0，失败返回-1

#### write函数

`a=write(fd ,buf,sizeof(buf))`：buf指写入的内容

成功返回写入的字节数，失败返回-1

#### read函数

`read(fd,buf,sizeof(buf))`

成功返回接收的字节数(但遇到文件结尾则返回0)，失败返回-1

## 套接字类型与协议设置

### 面向连接的套接字(SOCK_STREAM)

特征：

* 传输过程中数据不会消失
* 按序传输数据
* 传输的数据不存在数据边界

总结：可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字。

### 面向消息的套接字(SOCK_DGRAM)

特征：

* 强调快速传输而非传输顺序
* 传输的数据可能丢失也可能损毁
* 传输的数据又数据边界
* 限制每次传输的数据大小

总结：不可靠的、不按序传递的、以数据的高速传输为目的的套接字。

### 协议的最终选择

socket函数：

```c++
#include<sys/socket.h>
int socket(int domain, int type, int protocol);
```

`domain`：套接字中使用的协议族信息

`type`：套接字数据传输类型信息

`protocol`：计算机间通信中使用的协议信息

<strong style="color:red">协议族</strong>：

| 名称      | 协议族               |
| --------- | -------------------- |
| PF_INET   | IPV4互联网协议族     |
| PF_INET6  | IPV6互联网协议族     |
| PF_LOCAL  | 本地通信的UNIX协议族 |
| PF_PACKET | 底层套接字的协议族   |
| PF_IPX    | IPX Novell协议族     |



socket中第三个参数决定最终采用的协议。该参数大部分情况下为0，除非当同一协议族中存在多个数据传输方式相同的协议。

> 满足TCP套接字的协议只有IPPROTO_TCP，可省略
>
> 满足UDP套接字的协议只有IPPROTO_UDP，可省略

