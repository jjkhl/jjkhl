<!--
 * @Descripttion: 
 * @Author: jhl
 * @Date: 2021-12-08 22:13:40
 * @LastEditors: jjkhl
 * @LastEditTime: 2021-12-08 23:15:11
-->
# 面向对象高级编程上
1. 防止头文件被重复包含
```c++
//complex.h
#ifndef _COMPLEX_H
#define _COMPLEX_H

#endif
```
2. 前置声明：声明头文件中用到的类和函数
```c++
class complex;
```
3. 构造函数创建对象
```c++
complex c1(2,1);// complex(2, 1)
complex c2;	// complex(0, 0)
complex* p = new complex(4);// complex(4, 0)
```
4. 操作符重载
```c++
//1. 在类内声明public函数重载+=
inline complex& complex::operator +=(const complex& r)
{
    return ___doapl(this,r);
}
inline complex& __doapl(complex& c, const complex&r)
{
    c->re+r.re;
    c->im+=r.im;
    return *this;
}

//2.在类外声明函数重载+
inline complex operator +(const complex& x,const complex &y)
{
    return complex(real(x)+real(y),imaag(x)+imag(y));
}
//第二种方法返回的是局部对象，在退出函数时对象会被销毁，所以不能使用引用传递返回值。
```
5. 在类外声明函数重载<<
```c++
//1.返回ostream&类型
//类中使用friend声明为友元函数
friend ostream& operator<<(ostream& os,const complex &x);
//类外定义函数
ostream & operator<<(ostream &os,const complex &x)
{
    return os<<"("<<real(x)<<","<<imag(x)<<")";
}
//可以使用cout<<c1<<c2<<c3;

//2.返回void
//类中使用friend声明为友元函数
friend void operator <<(ostream& os,const complex &x);
//类外定义函数
void operator<<(ostream &oos, const complex &x)
{
   os<<"("<<real(x)<<","<<imag(x)<<")";
}
//无法使用cout<<c1<<c2;`
```