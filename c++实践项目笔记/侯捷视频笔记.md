<!--
 * @Descripttion: 
 * @Author: jhl
 * @Date: 2021-12-08 22:13:40
 * @LastEditors: jjkhl
 * @LastEditTime: 2021-12-15 17:43:31
-->
# 面向对象高级编程上
1. 防止头文件被重复包含
```c++
//complex.h
#ifndef _COMPLEX_H
#define _COMPLEX_H

#endif
```
2. 前置声明：声明头文件中用到的类和函数
```c++
class complex;
```
3. 构造函数创建对象
```c++
complex c1(2,1);// complex(2, 1)
complex c2;	// complex(0, 0)
complex* p = new complex(4);// complex(4, 0)
```
4. 操作符重载
```c++
//1. 在类内声明public函数重载+=
inline complex& complex::operator +=(const complex& r)
{
    return ___doapl(this,r);
}
inline complex& __doapl(complex& c, const complex&r)
{
    c->re+r.re;
    c->im+=r.im;
    return *this;
}

//2.在类外声明函数重载+
inline complex operator +(const complex& x,const complex &y)
{
    return complex(real(x)+real(y),imaag(x)+imag(y));
}
//第二种方法返回的是局部对象，在退出函数时对象会被销毁，所以不能使用引用传递返回值。
```
5. 在类外声明函数重载<<
```c++
//1.返回ostream&类型
//类中使用friend声明为友元函数
friend ostream& operator<<(ostream& os,const complex &x);
//类外定义函数
ostream & operator<<(ostream &os,const complex &x)
{
    return os<<"("<<real(x)<<","<<imag(x)<<")";
}
//可以使用cout<<c1<<c2<<c3;

//2.返回void
//类中使用friend声明为友元函数
friend void operator <<(ostream& os,const complex &x);
//类外定义函数
void operator<<(ostream &oos, const complex &x)
{
   os<<"("<<real(x)<<","<<imag(x)<<")";
}
//无法使用cout<<c1<<c2;`
```
6. 带有指针的成员函数需要重写拷贝构造和拷贝复制防止浅拷贝

```c++
Class String
{
    public:
        String(const char * cstr=0);
        String(const String& str);//拷贝构造
        String & operator=(const String & str);//拷贝复制
        ~String();
        char *get_c_str(){return m_data;}
    private:
        char *m_data;
};
inline String::String(const char *cstr=0)
{
    if(cstr)
    {
        m_data=new char[strlen(cstr)+1];
        strcpy(m_data,cstr);
    }
    else
    {
        m_data=new char[1];
        *m_data='\0;
    }
}

inline String::~String()
{
    //此处如果使用delete可能产生内存泄漏
    delete [] m_data;
}

inline String::String(const String& str)
{
    m_data=new char[strlen(str.m_data)+1];
    strcpy(m_data,str.m_data);
}
//拷贝赋值函数要检测自我赋值，不仅是出于效率考虑，也是为了防止出现bug
inline String & String::operator=(const String & str)
{
    if(this==&str)
        return *this;
    delete[] m_data;
    m_data=new char[strlen(str.m_data)+1];
    strcpy(m_data,str.m_data);
    return *this;
}
```

