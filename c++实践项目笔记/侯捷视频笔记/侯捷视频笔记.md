<!--
 * @Descripttion: 
 * @Author: jhl
 * @Date: 2021-12-08 22:13:40
 * @LastEditors: jjkhl
 * @LastEditTime: 2021-12-19 21:01:20
-->
# 面向对象高级编程上
1. 防止头文件被重复包含
```c++
//complex.h
#ifndef _COMPLEX_H
#define _COMPLEX_H

#endif
```
2. 前置声明：声明头文件中用到的类和函数
```c++
class complex;
```
3. 构造函数创建对象
```c++
complex c1(2,1);// complex(2, 1)
complex c2;	// complex(0, 0)
complex* p = new complex(4);// complex(4, 0)
```
4. 操作符重载
```c++
//1. 在类内声明public函数重载+=
inline complex& complex::operator +=(const complex& r)
{
    return ___doapl(this,r);
}
inline complex& __doapl(complex& c, const complex&r)
{
    c->re+r.re;
    c->im+=r.im;
    return *this;
}

//2.在类外声明函数重载+
inline complex operator +(const complex& x,const complex &y)
{
    return complex(real(x)+real(y),imaag(x)+imag(y));
}
//第二种方法返回的是局部对象，在退出函数时对象会被销毁，所以不能使用引用传递返回值。
```
5. 在类外声明函数重载<<
```c++
//1.返回ostream&类型
//类中使用friend声明为友元函数
friend ostream& operator<<(ostream& os,const complex &x);
//类外定义函数
ostream & operator<<(ostream &os,const complex &x)
{
    return os<<"("<<real(x)<<","<<imag(x)<<")";
}
//可以使用cout<<c1<<c2<<c3;

//2.返回void
//类中使用friend声明为友元函数
friend void operator <<(ostream& os,const complex &x);
//类外定义函数
void operator<<(ostream &oos, const complex &x)
{
   os<<"("<<real(x)<<","<<imag(x)<<")";
}
//无法使用cout<<c1<<c2;`
```
![](./侯捷视频笔记图片/重载运算符.png)

6. 在编写类的时候应该注意的5件事
* 构造函数中使用列表初始化(initialization list)为成员变量赋值.
* 常量成员函数使用const修饰.
* 参数的传递尽量考虑使用引用传递,若函数体内不改变传入的参数,应加以const修饰.
* 数据放入private中,大部分函数放入public中

7. 带有指针成员变量的类
```c++
class String
{
    public:
        String(const char* cstr=0);//构造函数
        String(const String& str);//拷贝构造
        String& operator=(const String& strr);//拷贝赋值
        ~String();//析构函数
        char *get_c_str() const {return m_data;}
    private:
        char *m_data;
};
inline String::String(const char *cstr=0)
{
    if(cstr)
    {
        m_daata=new char[strlen(cstr)+1];
        strcpy(m_data,cstr);
    }
    else
    {
        m_data=new char[1];
        *m_data='\0';
    }
}
inline String::~String()
{
    //直接使用delete会导致内存泄漏。
    delete[] m_data;
}

inline String::String(const String&str)
{
    m_data=new char[strlen(str.m_data)+1];
    strcpy(m_data,str.m_data);
}

inline String& String::operator=(const String& str)
{
    if(this==&str)
        return  *this;
    //上述为检测自我赋值功能。以防二者只想同一块内存然后产生问题
    delete[] m_data;
    m_data=new char[strlen(str.m_data)+1];
    strcpy(m_data,str.m_data);
    return *this;
} 

```
8. 堆栈与内存管理
* 栈(stack)是存在于某作用域(scope)的一块内存空间.例如当你调用函数,函数本身就会形成一个stack用来防治它所接收的参数以及返回地址.在函数本体内声明的任何变量,其所使用的内存块都取自上述stack.
* 堆(heap),是指由操作系统提供的一块global内存空间,程序可动态分配从其中获得若干区块.
```c++
class Complex {...};
...
{
    Complex c1(1,2);//c1占用stack的空间
    //Complex(3)是个临时对象，其所占用的空间是以new自heap动态分配得到的，并由p指向
    Complex *p=new Complex(3);
}
//c1为stack object，其生命周期在作用域(大括号)结束之际结束。这种作用域内的对象又被称为auto object，因为它会被自动清理。
```