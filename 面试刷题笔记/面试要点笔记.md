#面试要点总结
## [`snprintf`的使用](https://blog.csdn.net/bat67/article/details/52063813)
原型：int snprintf(char *str,int n,char *format[,argument,...])
参数对应：`待写入的字符串`，`要写入字符的最大数目`，`格式化字符串`，`输入字符串`
使用方式
```c++
#include<iostream>
#include<stdio.h>
using namespace std;
int main(int argc,char **argv)
{
    char str[5];
    int ret=snprintf(str,3,"%s","abcdefg");
    cout<<ret<<endl;//输出7，表示字符串长度
    cout<<str<<endl;
    system("pause");
    return 0;
}
```
## 进制间的转换
* [十进制转十六进制(包含负数)](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)
```c++
class Solution {
public:
    // 十六进制数对应的 16 种字符
    string s = "0123456789abcdef";

    string toHex(int num) {
        // 加上 2^32 后会爆 int 型，所以要用 long long 存储
        //因为题目给定的数在32位以内，所以取2^32次方；如果是8位，则取(1LL<8)
        long long n = (num < 0) ? (long long)num + (1ll << 32) : num;
        
        // 特判 n = 0 的情况
        if(n == 0) return "0";

        // 结果字符串
        string ret = "";
        while(n) {
            // 进制转换
            ret = s[n % 16] + ret;
            n /= 16;
        }
        return ret;
    }
};
```
## [字符串转整数](https://leetcode-cn.com/problems/string-to-integer-atoi/)
```c++
class Solution {
public:
    int myAtoi(string s) {
        int i=0;
        int flag=1;
        int len=s.size();
        while(s[i]==' ') i++;
        if(len==i||(!isdigit(s[i])&&s[i]!='+'&&s[i]!='-'))
            return 0;
        if(s[i]=='-'||s[i]=='+')
        {
            flag=s[i++]=='-'?-1:1;
        }
        long num=0;
        while(i<len&&isdigit(s[i]))
        {
            if(num>(INT_MAX-s[i]+'0')/10&&flag==1)
            {
                return INT_MAX;
            }
            else if(num>(INT_MAX-s[i]+'0')/10&&flag==-1)
            {
                return INT_MIN;
            }
            else
            {
                num=num*10+s[i++]-'0';
            }
        }
        return num*flag;
    }
};
```
## [next_permutation的使用](https://leetcode-cn.com/problems/next-permutation/)
```c++
//标准库的使用
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        next_permutation(nums.begin(),nums.end());
    }
};
//模拟法
//参考思路：https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-yi-kan-jiu-dong-by-ych-983q/
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int len=nums.size();
        int index=len-2;
        while(index>=0&&nums[index]>=nums[index+1])//从后往前找到第一个降序位置
            --index;
        if(index<0) reverse(nums.begin(),nums.end());
        else
        {
            int pos=len-1;
            while(nums[pos]<=nums[index])//找到第一个比index位置大的数
                --pos;
            swap(nums[pos],nums[index]);//交换
            reverse(nums.begin()+index+1,nums.end());//将降序区间变为最小排列的升序区间
        }
    }
};
```
## 智能指针
智能指针背后的核心概念是动态分配内存的所有权。智能指针被称为可以拥有或管理它所指向的对象。当需要让单个指针拥有动态分配的对象时，可以使用独占指针。对象的所有权可以从一个独占指针转移到另一个指针，其转移方式为：对象始终只能有一个指针作为其所有者。当独占指针离开其作用域或将要拥有不同的对象时，它会自动释放自己所管理的对象。
* [assert()函数](https://blog.csdn.net/cwdben/article/details/116053192)判断指针内容是否为空，空则无法通过。
### 专有指针(unique_ptr)
专有指针是最简单、最容易使用的智能指针之一，在声明的时候必须用模板参数指定类型，例如：
```c++
//初始化方式一
unique_ptr<int> p1(new int(10));
//方式二也可以先定义一个未初始化的指针，然后再赋值
unique_ptr<int> p2;
p2=unqiue_ptr<int> (new int);
*p2=10;
//方式三
unique_ptr<int> p1(new int);
*p1=10;
//c++14后有工厂函数make_unique在创建智能指针时强制初始化
auto p3=make_unique<int>(42);
//make_unique类似模板
template<class T,class... Args>//可变参数模板
std::unique_ptr<T>//返回的智能指针
my_make_unique(Arg&&... args)//可变参数模板的入口参数
{
    return std::unique_ptr<T>(
        new T(std::forward<Args>(args)...);//"完美转发"
    )
}
```
* unique_ptr所有权唯一，任何时候都只能有“一个人”拥有。必须使用`std::move()`显式声明所有权转移，此时原来的unique_ptr变成了空指针。
* 如果定义类时将`unique_ptr`作为成员，那么类本身也是不可复制的。也就是说，unique_ptr会将它“唯一所有权”特性传递给它的持有者。
<h5 align="center">unique_ptr成员函数</h5>

|成员函数|描述|
|:--:|:--|
|move|转移所有权|
|reset|销毁由该智能指针管理的任何可能存在的对象。该智能指针被置为空|
|reset(T* ptr)|销毁由该智能指针当前管理的任何可能存在的对象。该智能指针继续控制由裸指针 ptr 指向的对象|
|get()|返回该智能指针管理的由裸指针指向的对象。如果某个指针需要传递给函数，但是 该函数并不知道该如何操作智能指针，则 get() 函数非常有用|
|release|放弃对它所指对象的控制权，并返回保存的指针，将指针置为空，不会释放内存|
* release会返回直线的指针，但不会释放内存；reset会释放内存
```c++
// 将所有权从p1转移给p2
unique_ptr<string> p1(new string("abc"));
unique_ptr<string> p2(p1.release());   // p1.release()会将p1置空，并返回所指向的指针,此时*p2="abc";

unique_ptr<string> p3(new string("dfseg"));
// 将所有权从p3转移给p2
p2.reset(p3.release());  
// p3置空，并返回指针
// p2释放原来指向的对象，并重新指向p3的指针,*p2="dfseg"
//示例网址：https://blog.csdn.net/readyone/article/details/112297215
```
* 值传递需要使用move()，引用传递不需要
```c++
    //函数使用通过值传递的形参
    void fun1(unique_ptr<int> uptrParam)
    {
        cout << *uptrParam << endl;
    }
    //函数使用通过引用传递的值
    void fun2(unique_ptr<int>& up)
    {
        cout<<*up<<endl;
    }
    int main()
    {
        unique_ptr<int> uptr(new int);
        *uptr = 10;
        fun1(move (uptr)); // 在调用中使用 move
        fun2(uptr);
    }
```
### 共享指针(shared_ptr)
头文件：`memory`
与`unique_ptr`最大区别在于：它的所有权可以被安全共享，即支持复制赋值，允许被多个同时拥有。
```c++
auto p1=make_shared<int>(2);
//use_count()函数判断指针所有权
//p1.use_count()=1
auto p2=p1;
//p1.use_count()=2
//p2.use_count()=2
```
* shared_ptr能支持安全共享在于其内部使用了引用计数，最开始引用计数为1，表示只有一个持有者，如果发生复制赋值，也就是共享的时候，引用计数就会增加，而发生析构时，引用计数就会减少。只有当引用计数为0时，shared_ptr才会真正调用delete来释放内存。
* 同一指针不能同时为多个shared_ptr对象进行赋值
* 在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。
* 参考网址(http://c.biancheng.net/view/7898.html)
<h5 align="center">shared_ptr<T>模板类常用成员函数</h5>

|成员函数|描述|
|:--:|:--|
|swap()|交换2个相同类型shared_ptr指针的内容|
|reset()|当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1|
|get()|获得shared_ptr对象内部包含的普通指针|
|use_count()|返回同当前shared_ptr对象(包含它)指向相同的所有shared_ptr对象的数量|
|unique()|判断当前shared_ptr对象指向的堆内存，是否不再有其它shared_ptr对象指向它|

### 弱引用指针(weak_ptr)
头文件：`memory`
* 一般与`shared_ptr`类型指针搭配使用，当`weak_ptr`类型指针指向和某`shared_ptr`指针相同时，`weak_ptr `指针并不会使所指堆内存的引用计数加 1；同样，当` weak_ptr`指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，`weak_ptr` 类型指针并不会影响所指堆内存空间的引用计数。
* [成员函数](http://c.biancheng.net/view/7918.html)
<h5 align="center">weak_ptr成员函数</h5>

|成员函数|描述|
|:--:|:--|
|operator=()|重载`=`运算符，weak_ptr指针可以直接被weak_ptr或shared_ptr指针赋值|
|swap(x)|其中x表示同类型的weak_ptr指针，该函数可以互换2个同类型weak_ptr指针的内容|
|reset()|将当前weak_ptr指针置为空指针|
|use_count()|查看指向和当前weak_ptr指针相同的shared_ptr指针的数量|
|expired()|判断当前weak_ptr指针是否过期(指针为空，或指向的堆内存已经被释放)|
|lock()| 	如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相同的 shared_ptr 指针。|
* weak_ptr一个重要用途就是让类正确的自我创建shared_ptr；对象内部用weak_ptr来保管this指针，然后调用lock()获取shared_ptr
```c++
#include <iostream>
#include <memory>
using namespace std;
int main()
{
    std::shared_ptr<int> sp1(new int(10));
    std::shared_ptr<int> sp2(sp1);
    std::weak_ptr<int> wp(sp2);
    //输出和 wp 同指向的 shared_ptr 类型指针的数量
    cout << wp.use_count() << endl;
    //释放 sp2
    sp2.reset();
    cout << wp.use_count() << endl;
    //借助 lock() 函数，返回一个和 wp 同指向的 shared_ptr 类型指针，获取其存储的数据
    cout << *(wp.lock()) << endl;
    return 0;
}
```
## [虚函数](http://c.biancheng.net/cpp/biancheng/view/2988.html)
关键字：`virtual`
```c++
    #include <iostream>
    using namespace std;
    //基类Base
    class Base{
    public:
        virtual void func();
        virtual void func(int);
        virtual void funcA()=0;//纯虚函数
    };
    void Base::func(){
        cout<<"void Base::func()"<<endl;
    }
    void Base::func(int n){
        cout<<"void Base::func(int)"<<endl;
    }
    //派生类Derived
    class Derived: public Base{
    public:
        void func();
        void func(char *);
    };
    void Derived::func(){
        cout<<"void Derived::func()"<<endl;
    }
    void Derived::func(char *str){
        cout<<"void Derived::func(char *)"<<endl;
    }
    int main(){
        Base *p = new Derived();
        p -> func();  //输出void Derived::func()
        p -> func(10);  //输出void Base::func(int)
        //基类的指针智能访问从基类继承的成员，不能访问派生类新增的成员
        p -> func("http://c.biancheng.net");  //compile error
        return 0;
    }
```
## 联合(union)
联合与结构的区别：
(1). 结构和联合都是由多个不同的数据类型成员组成，但在任何同一时刻，联合中只存放了一个被选中的成员(即所有成员共用一块地址空间)，而结构的所有成员都存在(不同成员不共用地址空间)
(2). 对于联合的不同成员赋值，都会对其它成员重写，原来成员的值不存在了；结构不同成员赋值互不影响。
## 重载(overload)和重写(overried)
### 定义上的区别：
重载：允许存在多个同名函数，而这些参数的参数表不同
重写：子类重新定义父类虚函数的方法
### 实现原理上的区别
重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数，它们的地址在编译期就绑定了，因此，重载与堕胎无关。
重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的(晚绑定)。
## 列表初始化和赋值
必须使用初始化列表的3种情况：
* const常量成员
* 引用类型成员
* 没有默认构造函数的类
* 如果类存在继承关系，派生类必须在其初始化列表中调用基类的构造函数
```c++
#include <iostream>
using namespace std;
class Base
{
    public:
        Base(int a) : val(a) {}
    private:
        int val;
};
class A : public Base
{
    public:
        A(int v) : p(v), Base(v) {}//调用基类的构造函数
        void print_val() { cout << "hello:" << p << endl;}
    private:
        int p;
};
int main(int argc ,char **argv)
{
    int pp = 45;
    A b(pp);
    b.print_val();
}
``` 
## 内存分配
（1）栈：由编译器管理分配和回收，存放局部变量和函数参数。
（2）堆：由程序员管理，需要手动 new malloc delete free 进行分配和回收，空间较大，但可能会出现内存泄漏和空闲碎片的情况。
（3）全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。
（4）常量存储区：存储常量，一般不允许修改。
（5）代码区：存放程序的二进制代码。
## [静态成员函数](https://www.runoob.com/w3cnote/cpp-static-usage.html)
* 可以通过类名调用静态成员函数,当不可以调用非静态成员函数
```c++
class Point  
{  
public:   
    void init(){}
    static void output(){}
};  
int main()  
{  
    Point::init();//错误
    Point::output();//成功
}

```
* 类的对象可以调用静态成员函数和非静态成员函数
* 静态成员函数不能使用非静态成员
* 类的非静态成员函数可以调用静态成员函数，反之不能
* 类的静态成员变量必须在使用前初始化


**一般总结**
静态数据成员：
* 静态数据成员可以实现多个对象之间的数据共享，它在内存中只占一份空间。
* 静态数据成员在程序开始运行时被分配空间，到程序结束之后才被释放
* 静态数据成员只能在类外进行初始化，默认初始化为0
* 静态数据成员可以通过对象名引用，也可以通过类名引用
## const和static的区别
static：控制变量的存储方式和可见性
* 修饰局部变量：static修饰的局部变量会从栈区转移到静态存储区，其生命周期会一直延续到整个程序执行结束
* 修饰全局变量和函数：对于一个全局变量和函数，它可以在本文件或其它文件被访问。用static修饰的全局变量和函数只对本文件可见。
* 修饰类：对类中的某个函数用static修饰，则表示该函数属于一个类而不是此类的任何特定对象。
> 静态非常量成员，只能在类内声明，在类外定义和初始化，
## const和define的区别
const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被const修饰的东西都收到强制保护，可以防止意外变动，提高程序的健壮性。
* 类型检查：const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，对后者只能进行字符替换，没有类型安全检查
* 编译器处理方式：const在编译时确定值，define在预处理阶段进行替换
* 内存空间：const在静态存储区分配空间，在程序运行过程的内存中只有一个拷贝；define不分配内存，给出的是立即数没有多少次使用就进行多少次替换，在内存中会有多个拷贝，内存消耗大。
## [数组和数组指针](https://blog.csdn.net/cherrydreamsover/article/details/81741459)
* 在32位平台，sizeof(指针)=4；64位平台，sizeof(指针)=8
* 指针数组：`int *arr[8]`，arr是一个含有8个`int*`的数组；数组指针：`int (*arr)[8]`，指针arr指向一个大小为8个整型的数组
## 堆和栈的区别
栈：
* 由编译器进行管理，在需要时由编译器自动分配空间，在不需要时自动回收空间，一般保存`局部变量`和`函数参数`等。
* 连续的内存空间，在函数调用时，首先入栈的主函数的下一条可执行指令的地址，然后是函数的各个参数。
* 栈是高地址向低地址扩展，栈底高地址，空间较小

堆：
* 程序员管理，需要手动new(delete)、malloc(free)
* 不连续的空间，实际上系统中有一个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第一个大于等于申请大小的空间分配给程序，一般在分配程序的时候，也会空间头部写入内存大小，方便 delete 回收空间大小。当然如果有剩余的，也会将剩余的插入到空闲链表中，这也是产生`内存碎片`的原因。
* 堆是低地址向高地址扩展，空间较大，较为灵活。