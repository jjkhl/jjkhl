牛客项目网址：https://www.nowcoder.com/study/live/504?&headNav=www

# 第一章 Linux系统编程入门
## [配置环境](https://www.nowcoder.com/study/live/504/1/1)
[xshell和xftp下载地址](https://www.xshell.com/zh/)
linux安装ssh：`sudo apt install openssh-server`

## VMWARE静态IP
参考地址：https://blog.csdn.net/lianghecai52171314/article/details/113804465
步骤：
* 查看自己的网卡名称：`ifconfig`，可以看到自己网卡名称为`ens32`
* [编辑NAT模式](https://blog.csdn.net/qq_26796255/article/details/118915145?spm=1001.2014.3001.5506)：
  * 编辑→虚拟网络编辑器→更改设置
  * 选择NAT模式，下面两个勾选，设置子网IP和掩码
  * 设置网关地址：`192.168.0.2`
  * NAT设置→DNS设置，取消自动检测可用DNS服务器：首选`114.114.114.119`，备用：`114.114.115.119`
* 设置NAT网络连接，否则连接不上网络
* 修改本地VMnet8接口：
  * 
* 修改`/etc/netplan/xxx/yaml`文件：sudo vim /etc/netplan/xxx.yaml
* 添加内容
```
# Let NetworkManager manage all devices on this system
network:
  ethernets: 
    ens32: 
      addresses: [192.168.0.233/24]
      dhcp4: no
      optional: true
      gateway4: 192.168.0.2
      nameservers: 
        addresses: [114.114.114.119,114.114.115.119]

  version: 2
  renderer: NetworkManager
```

    * ip 地址和 DNS 服务器地址需要用[]括起来，但是网关地址不需要
    * 每个冒号后边都要先加一个空格
    * 每一层前边的缩进，至少比上一层多两个空格

* 生效配置：`sudo netplan apply`

查看IP地址：
* `hostname -I`
* `ifconfig`

## [静态库 ](https://www.nowcoder.com/study/live/504/1/4)
优势：代码保密以及方便部署和分发
[静态库的制作](http://c.biancheng.net/view/7168.html#:~:text=ar%20rcs%20%2B%20%E9%9D%99%E6%80%81%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8D%E5%AD%97%20%2B,%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%20ar%20%E6%98%AF%20Linux%20%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%87%E4%BB%BD%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E4%B8%80%E4%B8%AA%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%EF%BC%88%E4%B9%9F%E5%8F%AB%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BB%8E%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8F%90%E5%8F%96%E6%88%90%E5%91%98%E6%96%87%E4%BB%B6%E3%80%82)
* 生成目标文件.o：`gcc -c 源文件列表`
* 生成.a的静态链接库：`ar rcs 静态库名字(.a) 目标文件列表(.o)`

参数 r 用来替换库中已有的目标文件，或者加入新的目标文件。
参数 c 表示创建一个库。不管库否存在，都将创建。　
参数 s 用来创建目标文件索引，这在创建较大的库时能提高速度。

静态库名字规范：`lib(自定义名字).a`，比如`libcalc.a`

gcc编译方式一：`gcc main.c -o app -I ./include/ -l calc -L./lib`
-l指定库名，-L指定文件位置
gcc编译方式二：`gcc main.c ./lib/libcalc.a -I ./include/ -o app2`

##[动态库](https://www.nowcoder.com/study/live/504/1/6)
与静态库的区别：gcc进行链接时，动态库的代码不会被打包到可执行程序
查看依赖关系：`ldd main`
优点：
步骤：
* `.o`文件制作，得到与位置无关的代码：`gcc -c -fpic(或-fPIC) a.c b.c`
* 动态库`.so`制作：`gcc -shared a.o b.o -o libcalc.so`

gcc编译方式二： `gcc main.c lib/libcalc.so -o main -I include/`

动态库查找过程：先后搜索elf文件的 DT_RPATH段 ――> 环境变量LD_LIBRARY_PATH ――> /etc/ld.so.cache文件列表 ――> /lib/，/usr/lib目录找到库文件后将其载入内存。

> 更改LD_LIBRARY_PATH
> 
查看环境变量：`env`
临时新增LD_LIBRARY_PATH路径：`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/jhl/桌面/lib/`

用户级别永久新增：
* 移动到home目录：`cd ~`
* 编辑`.bashrc`：`vim .bashrc`
* 添加路径：`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/jhl/桌面/lib/`
* 生效：`source(.) .bashrc`

系统级别永久新增
* 修改文件：`sudo vim /etc/profile/`
* 添加路径：`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/jhl/桌面/lib/`
* 生效：`source(.) .bashrc`

> 更改/etc/ld.so.cache

步骤：
* 修改文件：`vim ~/etc/ld.so.conf`
* 添加路径：`/home/jhl/桌面/lib/`
* 生效：`sudo ldconfig`

## 动态库和静态库区别
静态库优点：
* 被打包后加载速度快
* 发布程序无需提供静态库，移植方便

缺点：
* 消耗系统资源，浪费内存
* 更新、部署、发布麻烦

动态库：
* 实现进程间资源共享
* 更新、部署和发布简单
* 可以控制加载动态库时间

缺点：
* 加载比静态库较慢
* 发布程序时需要提供依赖的动态库

## Makefile
文件名：`Makefile`

**变量：**
预定义变量：
AR：默认值ar
CC：c编译器
CXX：c++编译器

获取变量的值：
$@：目标的完整名称
$<：第一个依赖文件的名称
$^：所有依赖文件

**模式匹配：**
`%.o:%.c`
%：匹配一个字符串

**函数：**

* wildcard PATTERN...
    * 功能：获取指定目录下指定类型的文件列表
    * PATTERN：某个或多个目录对应的某种类型的文件，一般空格间隔
    * 返回：得到若干个文件的文件列表，文件名之间使用空格间隔
    * 实例：
  ```
  #(wildcard *.c ./sub/*.c)
  返回格式：a.c b.c c.c
  ```
* `$(patsubst <pattern>,<replacement>,<text>)`
    * 功能：查找`<text>`中的单词(以空格、tal或回车、换行分隔)是否符合模式`<pattern>`，如果匹配，则以`<replacement>`替换
    * `'\'`进行转义，`\%`表示真正的`%`字符
    * 返回：函数返回被替换后的字符串
    * 实例：
  ```
  $(patsubst %.c,%.o,x.c bar.c)
  返回值格式：x.o bar.o
  ```

同一目录下：
```
总体写法：
目标文件:使用文件列表
        shell命令
写法一：
app:sub.c add.c mult.c div.c main.c
        gcc sub.c add.c mult.c div.c main.c -o app
写法二：
app:sub.o add.o mult.o div.o main.o
        gcc sub.o add.o mult.o div.o main.o -o app1
sub.o:sub.c
        gcc -c sub.c -o sub.o
add.o:add.c
        gcc -c add.c -o add.o
mult.o:mult.c
        gcc -c mult.c -o mult.o
div.o:div.c
        gcc -c div.c -o div.o
main.o:main.c
        gcc -c main.c -o main.o 
写法三（变量法）：
#定义变量
src=sub.o add.o mult.o div.o main.o
target=app3
$(target):$(src)
        $(CC) $^ -o  $(target)
sub.o:sub.c
        gcc -c sub.c -o sub.o
add.o:add.c
        gcc -c add.c -o add.o
mult.o:mult.c
        gcc -c mult.c -o mult.o
div.o:div.c
        gcc -c div.c -o div.o
main.o:main.c
        gcc -c main.c -o main.o 

写法六：模式匹配
src=sub.o add.o mult.o div.o main.o
target=app3
$(target):$(src)
        $(CC) $^ -o  $(target)
%.o:%.c
        gcc -c $< -o $@

写法五：函数
1. wildcard
src=$(wildcard ./*.c)
target=app1
$(target):$(src)
        $(CC) $^ -o  $(target)
%.o:%.c
        gcc -c $< -o $@

2. patsubst
src=$(wildcard ./*.c)
objs=$(patsubst %.c,%.o,$(src))
target=app1
$(target):$(objs)
        $(CC) $(objs) -o  $(target)
%.o:%.c
        gcc -c $< -o $@

#定义为伪目标，不会对clean进行更新检查
.PHONY:clean
clean:
    rm $(objs) -f#删除生成的.o文件

手动clean命令行：`make clean`
```

## gdb调试
编译可调试文件：`g++ -g test.c test`
进入gdb：`gdb test`

设置参数：`set args 10 20`
查看参数：`show args`

查看当前文件代码：`l/list 行号(函数名)`
查看非当前文件代码：`list/l 文件名:行号(函数名)`

查看显示的行数：`show list/listsize`
设置显示的行数：`set list/listsize 函数`

设置断点：`b/break 行号(函数名、文件名:行号、文件名:函数)`
查看断点：`i/info b/break`
删除断点：`d/del/delete 断点编号`
设置断点无效：`dis/disable 断点编号`
设置断点生效：`ena/enable 断点编号`
设置条件断点：`b/break 10 if i==5`

运行程序：
* 程序停在第一行：`s/start`
* 程序停在断点处：`r/run`

继续运行到下一个断点：`c/continue`
单步执行(不会进入函数体)：`n/next`
单步执行(可以进入函数体)：`s/step`
跳出函数体：`finish`

打印变量：`p/print 变量名`
打印变量类型：`ptype 变量名`
自动打印变量操作：`display 变量名`
查看自动变量：`i/info display`
取消自动变量：`undisplay 编号`

设置变量值：`set var 变量名=变量值`
跳出循环：`until`



## 文件操作
复制文件
```c++
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>

int main()
{
	int fd1=open("english.txt",O_RDONLY);
	if(-1==fd1)
	{
		perror("open");
		return -1;
	}

	int fd2=open("cpy.txt",O_WRONLY|O_CREAT,0664);
	if(-1==fd2)
	{
		perror("open");
		return -1;
	}
	char buf[1024]={0};
	int len=0;
	while((len=read(fd1,buf,sizeof(buf)))>0)
	{
		write(fd2,buf,len);
	}
	close(fd1);
	close(fd2);
	return 0;
}
```

移动文件指针到文件头：`lseek(fd,0,SEEK_SET)`
获取当前文件指针的位置：`lseek(fd,0,SEEK_CUR)`
获取文件长度：`lseek(fd,0,SEEK_END)`
扩展文件长度(10b->100b)：`lseek(fd,100,SEEK_END)`

创造`a.txt`软链接`b.txt`：`ln -s a.txt b.txt`


模仿命令行指令`ls -l`：
```c++

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <pwd.h>
#include <grp.h>
#include <time.h>
#include <string.h>

// 模拟实现 ls -l 指令
// -rw-rw-r-- 1 nowcoder nowcoder 12 12月  3 15:48 a.txt
int main(int argc, char * argv[]) {

    // 判断输入的参数是否正确
    if(argc < 2) {
        printf("%s filename\n", argv[0]);
        return -1;
    }

    // 通过stat函数获取用户传入的文件的信息
    struct stat st;
    int ret = stat(argv[1], &st);
    if(ret == -1) {
        perror("stat");
        return -1;
    }

    // 获取文件类型和文件权限
    char perms[11] = {0};   // 用于保存文件类型和文件权限的字符串
    //S_IFMT=0170000(DEC)=1 111 000 000 000 000(BIN)
    switch(st.st_mode & S_IFMT) {
        case S_IFLNK:
            perms[0] = 'l';
            break;
        case S_IFDIR:
            perms[0] = 'd';
            break;
        case S_IFREG:
            perms[0] = '-';
            break; 
        case S_IFBLK:
            perms[0] = 'b';
            break; 
        case S_IFCHR:
            perms[0] = 'c';
            break; 
        case S_IFSOCK:
            perms[0] = 's';
            break;
        case S_IFIFO:
            perms[0] = 'p';
            break;
        default:
            perms[0] = '?';
            break;
    }

    // 判断文件的访问权限
    // 文件所有者
    perms[1] = (st.st_mode & S_IRUSR) ? 'r' : '-';
    perms[2] = (st.st_mode & S_IWUSR) ? 'w' : '-';
    perms[3] = (st.st_mode & S_IXUSR) ? 'x' : '-';

    // 文件所在组
    perms[4] = (st.st_mode & S_IRGRP) ? 'r' : '-';
    perms[5] = (st.st_mode & S_IWGRP) ? 'w' : '-';
    perms[6] = (st.st_mode & S_IXGRP) ? 'x' : '-';

    // 其他人
    perms[7] = (st.st_mode & S_IROTH) ? 'r' : '-';
    perms[8] = (st.st_mode & S_IWOTH) ? 'w' : '-';
    perms[9] = (st.st_mode & S_IXOTH) ? 'x' : '-';

    // 硬连接数
    int linkNum = st.st_nlink;

    // 文件所有者
    char * fileUser = getpwuid(st.st_uid)->pw_name;

    // 文件所在组
    char * fileGrp = getgrgid(st.st_gid)->gr_name;

    // 文件大小
    long int fileSize = st.st_size;

    // 获取修改的时间
    char * time = ctime(&st.st_mtime);

    char mtime[512] = {0};
    strncpy(mtime, time, strlen(time) - 1);

    char buf[1024];
    sprintf(buf, "%s %d %s %s %ld %s %s", perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[1]);

    printf("%s\n", buf);

    return 0;
}
```


# 第二章 Linux多进程开发
## 有关指令
查看进程：`ps aux/ajx`
u：显示进程的详细信息
x：显示没有控制终端的进程
j：列出与父进程相关的信息

杀死进程：`kill -9 id`

实时显示进程动态：`top`
-d：显示更新间隔
top执行后，以下按键进行排序：
m：内存使用量
p：CPU占有率
T：进程运行时间
U：用户名
K：输入指定PID杀死进程

进程号，类型为pid_t(整型)，范围：0~32767，唯一但是可以复用
父进程号：PPID，任何进程(除init进程)都是由父进程创建的
进程组：一个或多个进程的集合，它们之间互相关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号(PGID)，默认下当前进程号会当作当前的进程组号

## [gdb多进程调试](https://blog.csdn.net/qq_35116371/article/details/73479950)
视频网址：https://www.nowcoder.com/study/live/504/2/5
follow-fork-mode：parent(默认)、child
detach-on-fork：on(默认，同时调试父子进程)、off(只调试当前进程)

`set follow-fork-mode parent`
`show follow-fork-mode`

查看当前进程数量：`info inferiors`(*表示正在调试的进程)
切换指定ID的进程：`inferiors id`
断开GDB与id编号进程之间联系，使之独立运行：`detach inferiors id`
断开GDB与id编号进程之间联系，使之中断：`kill inferiors id`
从gdb进程列表中删除该进程：`remove-inferiors id`

## exec函数族

* int execl(const char *path, const char *arg, .../* (char *) NULL */);
* int execlp(const char *file, const char *arg, ... /* (char *) NULL */);
*  int execle(const char *path, const char *arg, .../*, (char *) NULL, char * const envp[] */);
*  int execv(const char *path, char *const argv[]);
*  int execvp(const char *file, char *const argv[]);
*  int execvpe(const char *file, char *const argv[], char *const envp[]);
*  int execve(const char *filename, char *const argv[], char *const envp[]);

path：需要指定的执行文件的路径或名称
file：需要执行的可执行文件的文件名
arg：可执行文件所需要的参数列表,第一个参数一般写执行程序的名字，最后一个参数以`NULL`结尾

使用exec函数后，就不执行后面的部分了
```c++
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
int main()
{
    pid_t pid = fork();
    if(pid>0)
    {
        printf("i am parent process, pid : %d\n",getpid());
        sleep(1);//孤儿线程的防止
    }
    else if(0==pid)
    {
        // execl("hello","hello",NULL);
        execl("/usr/bin/ps","ps","aux",NULL);//必须以NULL结尾
        printf("i am child process, pid : %d\n",getpid());//子进程不执行
    }
    //只有父进程执行
    for(int i=0;i<3;i++)
    {
        printf("i=%d, pid=%d\n",i,getpid());
    }
    return 0;
}
```

execlp可以从环境变量中进行查找
```c++
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
int main()
{
    pid_t pid = fork();
    if(pid>0)
    {
        printf("i am parent process, pid : %d\n",getpid());
        sleep(1);//防止孤儿线程:父进程结束但子进程未结束
    }
    else if(0==pid)
    {
        // execl("hello","hello",NULL);
        execlp("ps","ps","aux",NULL);//必须以NULL结尾
        printf("i am child process, pid : %d\n",getpid());//子进程不执行
    }
    //只有父进程执行
    for(int i=0;i<3;i++)
    {
        printf("i=%d, pid=%d\n",i,getpid());
    }
    return 0;
}
```

