牛客项目网址：https://www.nowcoder.com/study/live/504?&headNav=www

# 第一章 Linux系统编程入门
## [配置环境](https://www.nowcoder.com/study/live/504/1/1)
[xshell和xftp下载地址](https://www.xshell.com/zh/)
linux安装ssh：`sudo apt install openssh-server`

## VMWARE静态IP
参考地址：https://blog.csdn.net/lianghecai52171314/article/details/113804465
步骤：
* 查看自己的网卡名称：`ifconfig`，可以看到自己网卡名称为`ens32`
* [编辑NAT模式](https://blog.csdn.net/qq_26796255/article/details/118915145?spm=1001.2014.3001.5506)：
  * 编辑→虚拟网络编辑器→更改设置
  * 选择NAT模式，下面两个勾选，设置子网IP和掩码
  * 设置网关地址：`192.168.0.2`
  * NAT设置→DNS设置，取消自动检测可用DNS服务器：首选`114.114.114.119`，备用：`114.114.115.119`
* 设置NAT网络连接，否则连接不上网络
* 修改本地VMnet8接口：
  * 
* 修改`/etc/netplan/xxx/yaml`文件：sudo vim /etc/netplan/xxx.yaml
* 添加内容
```
# Let NetworkManager manage all devices on this system
network:
  ethernets: 
    ens32: 
      addresses: [192.168.0.233/24]
      dhcp4: no
      optional: true
      gateway4: 192.168.0.2
      nameservers: 
        addresses: [114.114.114.119,114.114.115.119]

  version: 2
  renderer: NetworkManager
```

    * ip 地址和 DNS 服务器地址需要用[]括起来，但是网关地址不需要
    * 每个冒号后边都要先加一个空格
    * 每一层前边的缩进，至少比上一层多两个空格

* 生效配置：`sudo netplan apply`

查看IP地址：
* `hostname -I`
* `ifconfig`

## [静态库 ](https://www.nowcoder.com/study/live/504/1/4)
优势：代码保密以及方便部署和分发
[静态库的制作](http://c.biancheng.net/view/7168.html#:~:text=ar%20rcs%20%2B%20%E9%9D%99%E6%80%81%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8D%E5%AD%97%20%2B,%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%20ar%20%E6%98%AF%20Linux%20%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%87%E4%BB%BD%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90%E4%B8%80%E4%B8%AA%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%EF%BC%88%E4%B9%9F%E5%8F%AB%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BB%8E%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8F%90%E5%8F%96%E6%88%90%E5%91%98%E6%96%87%E4%BB%B6%E3%80%82)
* 生成目标文件.o：`gcc -c 源文件列表`
* 生成.a的静态链接库：`ar rcs 静态库名字(.a) 目标文件列表(.o)`

参数 r 用来替换库中已有的目标文件，或者加入新的目标文件。
参数 c 表示创建一个库。不管库否存在，都将创建。　
参数 s 用来创建目标文件索引，这在创建较大的库时能提高速度。

静态库名字规范：`lib(自定义名字).a`，比如`libcalc.a`

gcc编译方式一：`gcc main.c -o app -I ./include/ -l calc -L./lib`
-l指定库名，-L指定文件位置
gcc编译方式二：`gcc main.c ./lib/libcalc.a -I ./include/ -o app2`

##[动态库](https://www.nowcoder.com/study/live/504/1/6)
与静态库的区别：gcc进行链接时，动态库的代码不会被打包到可执行程序
查看依赖关系：`ldd main`
优点：
步骤：
* `.o`文件制作，得到与位置无关的代码：`gcc -c -fpic(或-fPIC) a.c b.c`
* 动态库`.so`制作：`gcc -shared a.o b.o -o libcalc.so`

gcc编译方式二： `gcc main.c lib/libcalc.so -o main -I include/`

动态库查找过程：先后搜索elf文件的 DT_RPATH段 ――> 环境变量LD_LIBRARY_PATH ――> /etc/ld.so.cache文件列表 ――> /lib/，/usr/lib目录找到库文件后将其载入内存。

> 更改LD_LIBRARY_PATH
> 
查看环境变量：`env`
临时新增LD_LIBRARY_PATH路径：`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/jhl/桌面/lib/`

用户级别永久新增：
* 移动到home目录：`cd ~`
* 编辑`.bashrc`：`vim .bashrc`
* 添加路径：`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/jhl/桌面/lib/`
* 生效：`source(.) .bashrc`

系统级别永久新增
* 修改文件：`sudo vim /etc/profile/`
* 添加路径：`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/jhl/桌面/lib/`
* 生效：`source(.) .bashrc`

> 更改/etc/ld.so.cache

步骤：
* 修改文件：`vim ~/etc/ld.so.conf`
* 添加路径：`/home/jhl/桌面/lib/`
* 生效：`sudo ldconfig`

## 动态库和静态库区别
静态库优点：
* 被打包后加载速度快
* 发布程序无需提供静态库，移植方便

缺点：
* 消耗系统资源，浪费内存
* 更新、部署、发布麻烦

动态库：
* 实现进程间资源共享
* 更新、部署和发布简单
* 可以控制加载动态库时间

缺点：
* 加载比静态库较慢
* 发布程序时需要提供依赖的动态库

## Makefile
文件名：`Makefile`

**变量：**
预定义变量：
AR：默认值ar
CC：c编译器
CXX：c++编译器

获取变量的值：
$@：目标的完整名称
$<：第一个依赖文件的名称
$^：所有依赖文件

**模式匹配：**
`%.o:%.c`
%：匹配一个字符串

**函数：**

* wildcard PATTERN...
    * 功能：获取指定目录下指定类型的文件列表
    * PATTERN：某个或多个目录对应的某种类型的文件，一般空格间隔
    * 返回：得到若干个文件的文件列表，文件名之间使用空格间隔
    * 实例：
  ```
  #(wildcard *.c ./sub/*.c)
  返回格式：a.c b.c c.c
  ```
* `$(patsubst <pattern>,<replacement>,<text>)`
    * 功能：查找`<text>`中的单词(以空格、tal或回车、换行分隔)是否符合模式`<pattern>`，如果匹配，则以`<replacement>`替换
    * `'\'`进行转义，`\%`表示真正的`%`字符
    * 返回：函数返回被替换后的字符串
    * 实例：
  ```
  $(patsubst %.c,%.o,x.c bar.c)
  返回值格式：x.o bar.o
  ```

同一目录下：
```
总体写法：
目标文件:使用文件列表
        shell命令
写法一：
app:sub.c add.c mult.c div.c main.c
        gcc sub.c add.c mult.c div.c main.c -o app
写法二：
app:sub.o add.o mult.o div.o main.o
        gcc sub.o add.o mult.o div.o main.o -o app1
sub.o:sub.c
        gcc -c sub.c -o sub.o
add.o:add.c
        gcc -c add.c -o add.o
mult.o:mult.c
        gcc -c mult.c -o mult.o
div.o:div.c
        gcc -c div.c -o div.o
main.o:main.c
        gcc -c main.c -o main.o 
写法三（变量法）：
#定义变量
src=sub.o add.o mult.o div.o main.o
target=app3
$(target):$(src)
        $(CC) $^ -o  $(target)
sub.o:sub.c
        gcc -c sub.c -o sub.o
add.o:add.c
        gcc -c add.c -o add.o
mult.o:mult.c
        gcc -c mult.c -o mult.o
div.o:div.c
        gcc -c div.c -o div.o
main.o:main.c
        gcc -c main.c -o main.o 

写法六：模式匹配
src=sub.o add.o mult.o div.o main.o
target=app3
$(target):$(src)
        $(CC) $^ -o  $(target)
%.o:%.c
        gcc -c $< -o $@

写法五：函数
1. wildcard
src=$(wildcard ./*.c)
target=app1
$(target):$(src)
        $(CC) $^ -o  $(target)
%.o:%.c
        gcc -c $< -o $@

2. patsubst
src=$(wildcard ./*.c)
objs=$(patsubst %.c,%.o,$(src))
target=app1
$(target):$(objs)
        $(CC) $(objs) -o  $(target)
%.o:%.c
        gcc -c $< -o $@

#定义为伪目标，不会对clean进行更新检查
.PHONY:clean
clean:
    rm $(objs) -f#删除生成的.o文件

手动clean命令行：`make clean`

如果需要同时执行，可以定义一个all
all:$(target) clean
```

## gdb调试
编译可调试文件：`g++ -g test.c test`
进入gdb：`gdb test`

设置参数：`set args 10 20`
查看参数：`show args`

查看当前文件代码：`l/list 行号(函数名)`
查看非当前文件代码：`list/l 文件名:行号(函数名)`

查看显示的行数：`show list/listsize`
设置显示的行数：`set list/listsize 数字`

设置断点：`b/break 行号(函数名、文件名:行号、文件名:函数)`
查看断点：`i/info b/break`
删除断点：`d/del/delete 断点编号`
设置断点无效：`dis/disable 断点编号`
设置断点生效：`ena/enable 断点编号`
设置条件断点：`b/break 10 if i==5`

运行程序：
* 程序停在第一行：`s/start`
* 程序停在断点处：`r/run`

继续运行到下一个断点：`c/continue`
单步执行(不会进入函数体)：`n/next`
单步执行(可以进入函数体)：`s/step`
跳出函数体：`finish`

打印变量：`p/print 变量名`
打印变量类型：`ptype 变量名`
自动打印变量操作：`display 变量名`
查看自动变量：`i/info display`
取消自动变量：`undisplay 编号`

设置变量值：`set var 变量名=变量值`
跳出循环：`until`



## 文件操作
复制文件
```c++
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>

int main()
{
	int fd1=open("english.txt",O_RDONLY);
	if(-1==fd1)
	{
		perror("open");
		return -1;
	}

	int fd2=open("cpy.txt",O_WRONLY|O_CREAT,0664);
	if(-1==fd2)
	{
		perror("open");
		return -1;
	}
	char buf[1024]={0};
	int len=0;
	while((len=read(fd1,buf,sizeof(buf)))>0)
	{
		write(fd2,buf,len);
	}
	close(fd1);
	close(fd2);
	return 0;
}
```

移动文件指针到文件头：`lseek(fd,0,SEEK_SET)`
获取当前文件指针的位置：`lseek(fd,0,SEEK_CUR)`
获取文件长度：`lseek(fd,0,SEEK_END)`
扩展文件长度(10b->100b)：`lseek(fd,100,SEEK_END)`

创造`a.txt`软链接`b.txt`：`ln -s a.txt b.txt`


模仿命令行指令`ls -l`：
```c++

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <pwd.h>
#include <grp.h>
#include <time.h>
#include <string.h>

// 模拟实现 ls -l 指令
// -rw-rw-r-- 1 nowcoder nowcoder 12 12月  3 15:48 a.txt
int main(int argc, char * argv[]) {

    // 判断输入的参数是否正确
    if(argc < 2) {
        printf("%s filename\n", argv[0]);
        return -1;
    }

    // 通过stat函数获取用户传入的文件的信息
    struct stat st;
    int ret = stat(argv[1], &st);
    if(ret == -1) {
        perror("stat");
        return -1;
    }

    // 获取文件类型和文件权限
    char perms[11] = {0};   // 用于保存文件类型和文件权限的字符串
    //S_IFMT=0170000(DEC)=1 111 000 000 000 000(BIN)
    switch(st.st_mode & S_IFMT) {
        case S_IFLNK:
            perms[0] = 'l';
            break;
        case S_IFDIR:
            perms[0] = 'd';
            break;
        case S_IFREG:
            perms[0] = '-';
            break; 
        case S_IFBLK:
            perms[0] = 'b';
            break; 
        case S_IFCHR:
            perms[0] = 'c';
            break; 
        case S_IFSOCK:
            perms[0] = 's';
            break;
        case S_IFIFO:
            perms[0] = 'p';
            break;
        default:
            perms[0] = '?';
            break;
    }

    // 判断文件的访问权限
    // 文件所有者
    perms[1] = (st.st_mode & S_IRUSR) ? 'r' : '-';
    perms[2] = (st.st_mode & S_IWUSR) ? 'w' : '-';
    perms[3] = (st.st_mode & S_IXUSR) ? 'x' : '-';

    // 文件所在组
    perms[4] = (st.st_mode & S_IRGRP) ? 'r' : '-';
    perms[5] = (st.st_mode & S_IWGRP) ? 'w' : '-';
    perms[6] = (st.st_mode & S_IXGRP) ? 'x' : '-';

    // 其他人
    perms[7] = (st.st_mode & S_IROTH) ? 'r' : '-';
    perms[8] = (st.st_mode & S_IWOTH) ? 'w' : '-';
    perms[9] = (st.st_mode & S_IXOTH) ? 'x' : '-';

    // 硬连接数
    int linkNum = st.st_nlink;

    // 文件所有者
    char * fileUser = getpwuid(st.st_uid)->pw_name;

    // 文件所在组
    char * fileGrp = getgrgid(st.st_gid)->gr_name;

    // 文件大小
    long int fileSize = st.st_size;

    // 获取修改的时间
    char * time = ctime(&st.st_mtime);

    char mtime[512] = {0};
    strncpy(mtime, time, strlen(time) - 1);

    char buf[1024];
    sprintf(buf, "%s %d %s %s %ld %s %s", perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[1]);

    printf("%s\n", buf);

    return 0;
}
```


# 第二章 Linux多进程开发
## 有关指令
查看进程：`ps aux/ajx`
u：显示进程的详细信息
x：显示没有控制终端的进程
j：列出与父进程相关的信息

杀死进程：`kill -9 id`

实时显示进程动态：`top`
-d：显示更新间隔
top执行后，以下按键进行排序：
m：内存使用量
p：CPU占有率
T：进程运行时间
U：用户名
K：输入指定PID杀死进程

进程号，类型为pid_t(整型)，范围：0~32767，唯一但是可以复用
父进程号：PPID，任何进程(除init进程)都是由父进程创建的
进程组：一个或多个进程的集合，它们之间互相关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号(PGID)，默认下当前进程号会当作当前的进程组号

## [gdb多进程调试](https://blog.csdn.net/qq_35116371/article/details/73479950)
视频网址：https://www.nowcoder.com/study/live/504/2/5
follow-fork-mode：parent(默认)、child
detach-on-fork：on(默认，同时调试父子进程)、off(只调试当前进程)

`set follow-fork-mode parent`
`show follow-fork-mode`

查看当前进程数量：`info inferiors`(*表示正在调试的进程)
切换指定ID的进程：`inferiors id`
断开GDB与id编号进程之间联系，使之独立运行：`detach inferiors id`
断开GDB与id编号进程之间联系，使之中断：`kill inferiors id`
从gdb进程列表中删除该进程：`remove-inferiors id`

## exec函数族

* int execl(const char *path, const char *arg, .../* (char *) NULL */);
* int execlp(const char *file, const char *arg, ... /* (char *) NULL */);
*  int execle(const char *path, const char *arg, .../*, (char *) NULL, char * const envp[] */);
*  int execv(const char *path, char *const argv[]);
*  int execvp(const char *file, char *const argv[]);
*  int execvpe(const char *file, char *const argv[], char *const envp[]);
*  int execve(const char *filename, char *const argv[], char *const envp[]);

path：需要指定的执行文件的路径或名称
file：需要执行的可执行文件的文件名
arg：可执行文件所需要的参数列表,第一个参数一般写执行程序的名字，最后一个参数以`NULL`结尾

使用exec函数后，就不执行后面的部分了
```c++
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
int main()
{
    pid_t pid = fork();
    if(pid>0)
    {
        printf("i am parent process, pid : %d\n",getpid());
        sleep(1);//孤儿线程的防止
    }
    else if(0==pid)
    {
        // execl("hello","hello",NULL);
        execl("/usr/bin/ps","ps","aux",NULL);//必须以NULL结尾
        printf("i am child process, pid : %d\n",getpid());//子进程不执行
    }
    //只有父进程执行
    for(int i=0;i<3;i++)
    {
        printf("i=%d, pid=%d\n",i,getpid());
    }
    return 0;
}
```

execlp可以从环境变量中进行查找
```c++
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
int main()
{
    pid_t pid = fork();
    if(pid>0)
    {
        printf("i am parent process, pid : %d\n",getpid());
        sleep(1);//防止孤儿线程:父进程结束但子进程未结束
    }
    else if(0==pid)
    {
        // execl("hello","hello",NULL);
        execlp("ps","ps","aux",NULL);//必须以NULL结尾
        printf("i am child process, pid : %d\n",getpid());//子进程不执行
    }
    //只有父进程执行
    for(int i=0;i<3;i++)
    {
        printf("i=%d, pid=%d\n",i,getpid());
    }
    return 0;
}
```

pid_t wait(int *status);

WIFEXITED(status)：非0，进程正常退出
WIFSIGNALED(status)：非0 表明进程异常终止。
```c++
#include <sys/types.h>
#include <sys/wait.h>
pid_t waitpid(pid_t pid, int *wstatus, int options);
  功能：回收指定进程号的子进程，可以设置是否阻塞。
  参数：
      - pid:
          pid > 0 : 某个子进程的pid
          pid = 0 : 回收当前进程组的所有子进程    
          pid = -1 : 回收任意的子进程，相当于 wait()  （最常用）
          pid < -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程
      - options：设置阻塞或者非阻塞
          0 : 阻塞
          WNOHANG : 非阻塞
      - 返回值：
          > 0 : 返回子进程的id
          = 0 : options=WNOHANG, 表示还有子进程或者
          = -1 ：错误，或者没有子进程了
```

## 进程间通信(IPC)
![](picture/Linux进程间通信方式.png)
### 管道
管道是一个内核内存中维护的缓冲器，可以进行读、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。

一个管道是一个字节流，使用管道时不存在消息或消息边界概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块大小是多少。

从管道读取的字节顺序和被写入管道顺序一致。

管道中数据的传递方向是单向的，管道输入半双工。

管道中读取数据是一次性操作，无法使用lseek()来随机访问数据。

匿名管道只能狗仔具有公共祖先的进程之间使用。

创建匿名管道：
```c++
#include<unistd.h>
int pipe(int pipefd[2]);
```

查看管道缓冲大小：`ulimit -a`
查看管道缓冲大小函数：
```c++
#include<unistd.h>
long fpathconf(int fd,int name);
```
```c++
/*
    实现 ps aux | grep xxx 父子进程间通信
    
    子进程： ps aux, 子进程结束后，将数据发送给父进程
    父进程：获取到数据，过滤
    pipe()
    execlp()
    子进程将标准输出 stdout_fileno 重定向到管道的写端。  dup2
*/

#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wait.h>

int main() {

    // 创建一个管道
    int fd[2];
    int ret = pipe(fd);

    if(ret == -1) {
        perror("pipe");
        exit(0);
    }

    // 创建子进程
    pid_t pid = fork();

    if(pid > 0) {
        // 父进程
        // 关闭写端
        close(fd[1]);
        // 从管道中读取
        char buf[1024] = {0};

        int len = -1;
        while((len = read(fd[0], buf, sizeof(buf) - 1)) > 0) {
            // 过滤数据输出
            printf("%s", buf);
            memset(buf, 0, 1024);
        }

        wait(NULL);

    } else if(pid == 0) {
        // 子进程
        // 关闭读端
        close(fd[0]);

        // 文件描述符的重定向 stdout_fileno -> fd[1]
        dup2(fd[1], STDOUT_FILENO);
        // 执行 ps aux
        execlp("ps", "ps", "aux", NULL);
        perror("execlp");
        exit(0);
    } else {
        perror("fork");
        exit(0);
    }
    return 0;
}
```

管道读写特点：
* 读端(从管道读取)：
  * 管道中有数据：read返回实际读到的字节数
  * 管道中无数据：
    * 写端被完全关闭，read返回0
    * 写端没有完全关闭，read阻塞等待
* 写端(写入管道)：
  * 管道读端全部被关闭：进程异常终止(进程收到SIGPIPE信号)
  * 管道读端没有全被关闭：
    * 管道已满，write阻塞
    * 管道没有满，write将数据写入，并返回实际写入的字节数

有名管道：又称命名管道、FIFO(first in first out)文件。通过FIFO不相关的进程也能交换数据。

创建有名管道：`mkfifo 名字`
函数法：
```c++
#include<sys/stat.h>
#include<sys/types.h>
int mkfifo(const char*pathname,mode_t mode);
//常见的I/o函数都可以使用，但不支持文件定位，只能从开始处读取数据，末尾写入数据
```

有名管道的注意事项：
1. 一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道
2. 一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道

### 内存映射
```
#include <sys/mman.h>
    void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
        - 功能：将一个文件或者设备的数据映射到内存中
        - 参数：
            - void *addr: NULL, 由内核指定
            - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。
                    获取文件的长度：stat lseek
            - prot : 对申请的内存映射区的操作权限
                -PROT_EXEC ：可执行的权限
                -PROT_READ ：读权限
                -PROT_WRITE ：写权限
                -PROT_NONE ：没有权限
                要操作映射内存，必须要有读的权限。
                PROT_READ、PROT_READ|PROT_WRITE
            - flags :
                - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项
                - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）
            - fd: 需要映射的那个文件的文件描述符
                - 通过open得到，open的是一个磁盘文件
                - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。
                    prot: PROT_READ                open:只读/读写 
                    prot: PROT_READ | PROT_WRITE   open:读写
            - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不便宜。
        - 返回值：返回创建的内存的首地址
            失败返回MAP_FAILED，(void *) -1

    int munmap(void *addr, size_t length);
        - 功能：释放内存映射
        - 参数：
            - addr : 要释放的内存的首地址
            - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。
```
### 信号
信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。

信号表
|编号|信号名称|对应事件|默认动作|
|:--:|:--:|:--:|:--:|
|1|SIGHUP|用户退出shell时，由该shell启动的所有进程将收到该信号|终止进程|
|2|<strong style="color:red">SIGINT</strong>|当用户按下<Ctrl+C>组合键，用户终端向正在运行中的由该终端启动的程序发出此信号|终止进程|
|3|<strong style="color:red">SIGQUIT</strong>|用户按下<ctrl+\>产生该型号，终端向正在运行中的由该终端启动的程序发出些信号|终止进程|
|4|SIGILL|CPU检测到某进程执行了非法指令|终止进程并产生core文件|
|5|SIGTRAP|由断点指令或其他trap指令产生|终止进程并产生core文件|
|6|SIGABRT|调用abort函数时产生|终止进程并产生core文件|
|7|SIGBUS|非法访问内存地址，包括内存对齐出错|终止进程并产生core文件|
|8|SIGFPE|在发生致命的运算错误时发出。包括浮点运算错误、溢出以及除数被0等算法错误|终止进程并产生core文件|
|9|<strong style="color:red">SIGKILL</strong>|无条件终止进程。该信号不能被忽略、处理和阻塞|终止进程，可以杀死任何进程|
|10|SIGUSE1|用户定义的信号。|终止进程|
|11|<strong style="color:red">SIGSEGV</strong>|进程进行了无效内存访问(段错误)|终止进程并产生core文件|
|12|SIGUSER2|另外一个用户自定义信号|终止进程|
|13|<strong style="color:red">SIGPIPE</strong>|Broken pipe向一个没有读端的管道写入数据|终止进程|
|14|SIGALRM|定时器超时，超时时间由系统调用alarm设置|终止进程|
|15|SIGTERM|程序结束信号，但该信号可以被阻塞和终止。通常原来表示程序正常退出。kill缺省产生这个信号|终止进程|
|16|SIGSTKFLT|Linux早期版本出现信号|终止进程|
|17|<strong style="color:red">SIGCHLD</strong>|子进程结束时，父进程会收到这个信号|忽略这个信号|
|18|<strong style="color:red">SIGCONT|如果进程已停止，则使其继续运行|继续/忽略|
|19|<strong style="color:red">SIGSTOP</strong>|停止进程的执行。信号不能被忽略、处理和阻塞|终止进程|
|20|SIGTSTP|停止终端交互进程的运行。按下<ctrl+z>组合键触发|暂停进程|
|21|SIGTTIN|后台进程读终端控制台|暂停进程|
|22|SIGTTOU|后台进程向终端输出数据时发生|暂停进程|
|23|SIGURG|套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达|忽略该信号|
|24|SIGXCPU|进程执行时间超过了该进程的CPU时间，系统产生该信号并发送给该进程|终止进程|
|25|SIGXFSZ|超过文件的最大长度设置|终止进程|
|26|SIGVTALRM|虚拟时钟超时时产生该信号，只计算该进程占用CPU的使用时间|终止进程|
|27|SIGIPROF|类似于SIGVTALRM，不仅包括该进程占用CPU时间还包括执行系统调用时间|终止进程|
|28|SIGWINCH|窗口变化大小时发出|忽略该信号|
|29|SIGIO|向进程指示发出了一个异步IO事件|忽略该信号|
|30|SIGPWR|关机|终止进程|
|31|SIGSYS|无效的系统调用|终止进程并产生core文件|
|34~64|SIGRTMIN~SIGRTMAX|Linux实时信号，可以自定义|终止进程|

查看信号的详细信息：`man 7  signal`

信号默认处理动作：
* Term 终止进程
* Ign 当前进程忽略该信号
* Core 终止进程，并生成一个Core文件
* Stop 暂停当前进程
* Cont 继续执行当前被暂停的进程

信号的状态：产生、未决、递达
未决：是一种状态，指的是从信号的产生到信号被处理前的这段时间
阻塞：开关动作，指的是阻止信号被处理，但不阻止信号产生。目的是让系统暂时保留信号留待以后发生。
多个信号可以使用信号集表示，数据类型为`sigset_t`

# 第五章 项目实战与总结
阻塞和非阻塞、异步和同步
![](picture/阻塞、非阻塞、同步、异步.png)

在处理IO时，阻塞和非阻塞都是同步IO，只有使用了特殊的API才是异步IO

一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。

<table>
    <tr>
       <td rowspan="2">同步</td>
       <td colspan="2">IO multiplexing(select/poll/epoll)</td>
    </tr>
    <tr>
       <td>阻塞</td>
       <td>非阻塞</td>
    </tr>
</table>

<table>
    <tr>
        <td rowspan="2">异步</td>
        <td>Linux</td>
        <td>Windows</td>
        <td>.NET</td>
    </tr>
    <tr>
        <td>AIO</td>
        <td>IOCP</td>
        <td>BeginInvoke/EndInvoke</td>
    </tr>
</table>
同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；

异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。