<h1 align="center">并发编程笔记</h1>

中文原书：[c++并发编程](c++并发编程.pdf)

原版英文：[C++ Concurrency in Action 2nd Edition-2019-英文版](C++ Concurrency in Action 2nd Edition-2019-英文版.pdf)

## 基础概念

### 并发

概念：单个系统同时执行多个独立的任务。

使用原因：关注点分离和性能。

> 关注点分离：通过将无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能性。
>
> 任务并行：将一个单个任务分成几部分，且各自并行运行，从而降低总运行时间。
>
> 可并行的方式：与其同时处理一个文件，不如酌情处理多个文件。

### 多进程并发

概念：将应用程序分为多个独立的进程，在同一时刻运行

优点：可以使用远程链接的方式；

​			在进程间提供附加的保护操作和更高级别的通信机制，更容易编写安全的并发代码

缺点：需要的固定开销大

### 多线程并发

概念：在单个进程中运行多个线程。进程中的所有线程都共享地址空间，并且所有线程访问到的大部分数据——全局变了仍然是全局的。进程之间共享内存，但是同一数据的内存地址在不同的进程中不同。

优点：开销远小于使用多个进程。

缺点：要确保每个线程所访问到的数据是一致的。

### 入门

```c++
#include <iostream>
#include <thread>		//①
void hello()			//②
{
    std::cout<<"Hello Concurrent World\n";
}
int main()
{
    std::thread t(hello);	   //③
    t.join();			     //④
}
```

管理线程的函数和类在<font color='red'>**thread**</font>中声明，而保护共享数据的函数和类在其他头文件中声明。

每个线程都必须有一个初始化函数，比如独立函数②。

对于应用程序来说，初始线程使main()，但是对于其他线程，可以在<font color='red'>**std::thread**</font>对象的构造函数中指定，如本例中③位置。

新的线程③启动之后，初始线程继续执行。如果它不等新线程结束，有可能在新线程开始之前就结束程序。

④调用join()，使调用线程等待与<font color='red'>**std::thread**</font>对象相关联的线程。

## 线程管理

### 启动线程

c++线程库启动线程，可以归结为构造<font color='red'>**std::thread**</font>对象。

> //相当于声明了一个叫my_thread的函数，带有一个参数(函数指针没有参数并返回background_task对象的函数)，而非启动了一个线程。
>
> std::thread my_thread(background_task()); 	
>
> //正确方式
>
> std::thread my_thread((background_task()));
>
> std::thread my_thread{background_task()};  

### 等待线程完成

将销毁程序的detach()替换为<strong style="color:red">join()</strong>：确保局部变量在线程完成后，才被销毁。

一个线程只能使用一次join()；

### 特殊情况下的等待

拷贝构造函数和拷贝赋值操作被标记为=delete，是为了不让编译器自动生成。直接对一个对象进行拷贝和赋值可能会弄丢已经加入的线程。

### 后台运行线程

detach()会让线程在后台运行，意味着主线程不能与之产生直接交互。

## 向线程函数传递参数

### 向线程函数传递参数

```c++
void f(int i,std::string const &s);
std::thread t(f,3,"hello");
```

**动态指针作为参数传递给线程**：

```c++
std::thread t(f,3,std::string(buffer));//避免悬垂指针
```

**传递一个直接引用而不是复制后的引用**

```c++
//std::ref——将参数转换为引用的形式
void update_data_for_widget(widget_id w,widget_data& data);
std::thread t(update_data_for_widget,w,std::ref(data));  
```

**移动操作可以将对象转换为可接受的类型**：std::move

执行线程的所有权可以在多个**std::thread**实例中互相转移，主要是**std::thread**实例的可移动且不可复制性。

> 不可复制：保证在同一个时间点，一个**std::thread**实例只能关联一个执行线程。
>
> 可移动性：让程序员决定哪个实例拥有实际执行线程的所有权

### 转移线程所有权

新线程所有权都需要转移，并且需要等待线程结束。

```c++
void some_function();
void some_other_function();
std::thread t1(some_function);//①
std::thread t2=std::move(t1);//②
t1=std::thread(some_other_function);//③
std::thread t3;//④
t3=std::move(t2);//⑤
t1=std::move(t3);//⑥ 赋值操作将程序崩溃，因为t1已经有关联的线程
```

②操作将t1的所有权转移给t2，之后t1和执行线程没有关联，执行some_function的函数现在与t2关联。

与一个临时**std::thread**对象相关的线程启动了③。因为所有者是一个临时对象—移动操作将会隐式调用，所以不显示使用**std::move**转移所有权。

④默认构造t3，与任何执行线程没有关联。

⑤将t2关联线程的所有权转移到t3中，因为t2是一个命名对象。⑤操作完成后，t1与执行some_other_function的线程相关联，t2与任何线程都无关联，t3与执行some_function的线程相关联。

### 运行时决定线程数量

std::hardware_concurrency()

### 识别线程

1. 调用std::thread对象的成员函数get_id()直接获取
2. 调用std::get_id()函数(位于<thread>头文件中)

## 线程之间共享数据

### 共享数据带来的问题

**条件竞争**

并发中竞争条件的形成，取决于一个以上线程的相对执行顺序，每个线程都抢着完成自己的任务。

> 解决方式：
>
> 1.对数据结构采取保护机制——确保只有进行修改的线程才能看到不变量被破坏时的中间状态，从其他访问线程角度来看，修改不是已经完成就是还没开始。
>
> 2.对数据结构和不变量的设计进行设计，修改完的结构必须能完成一系列不可分割的变化，也就是保证每个不变量保持稳定的结构，这就是所谓的无锁编程。

### 使用互斥量保护共享数据

头文件：<mutex>

使用实例化std::mutex创建互斥量，通过调用成员函数lock()上锁，unlock()进行解锁。 

std::lock_guard：在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证可一个已锁的互斥量总是会被正确的解锁。

```c++
#include<list>
#include<mutex>
#include<algorithm>
std::list<int> some_list;//①
std::mutex some_mutex;//②
void add_to_list(int new_value)
{
    std::lock_guard<std::mutex> guard(some_mutex);//③
    some_list.push_back(new_value);
}
bool list_contains(int value_to_find)
{
    std::lock_guard<std::mutex> guard(some_mutex);//④
    return std::find(some_list.begin(),some_list.end(),value_to_find)!=some_list.end();
}
```

全局变量some_list被全局互斥量some_mutex保护。add_to_list()和list_contains()使用，使得这两个函数中对数据的访问是互斥的。

大多数情况下，互斥量会与保护的数据放在同一个类中，而不是定义成全局变量。

> 面向对象的设计准则：放在一个类中的数据可以让它们联系在一起，也可对类的功能进行封装并进行数据保护。

**切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去**

### 死锁问题及解决方案

问题：由两个及以上的互斥量来锁定一个操作，或者线程之间互相等待

一般建议：总在互斥B之前锁住互斥量A。

std::lock可以一次性锁住多个的互斥量，并且没有死锁的风险。

**避免嵌套锁**：每个线程只能有一个锁，锁上就不会死锁。

**避免在持有锁时调用用户提供的代码**

**使用固定顺序获取锁**

### std::unique_lock

1. 可将std::adopt_lock作为第二参数传入构造函数，对互斥量进行管理。
2. 可将std::defer_lock作为第二参数传递，表明互斥量保持解锁状态

## 实践操作

[多线程编程基础方式](./多线程编程基础方式.md)

### 基本过程

* 包含头文件`<thread>`

* 写初始函数

* main中写代码

```c++
#include<thread>
#include<iostream>
using namespace std;
void myprint()
{
	cout << "线程开始执行" << endl;

	cout << "线程执行完毕" << endl;
}
int main()
{
	thread myjob(myprint);//创建线程，线程执行七点myprint()
   	   //myprint开始执行
	myjob.join();//阻塞主线程，让主线程等待子线程执行完毕
	//子线程执行完毕，主线程继续往前
	cout << "I Love China" << endl;
	return 0;
}
```

​        detach()：分离主线程和子线程，让两者互不干涉——2.2:  40

