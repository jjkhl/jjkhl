<h1 align="center">并发编程笔记</h1>
中文原书：[c++并发编程](c++并发编程.pdf)

原版英文：[C++ Concurrency in Action 2nd Edition-2019-英文版](C++ Concurrency in Action 2nd Edition-2019-英文版.pdf)

## 基础概念

### 并发

概念：单个系统同时执行多个独立的任务。

使用原因：关注点分离和性能。

> 关注点分离：通过将无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能性。
>
> 任务并行：将一个单个任务分成几部分，且各自并行运行，从而降低总运行时间。
>
> 可并行的方式：与其同时处理一个文件，不如酌情处理多个文件。

### 多进程并发

概念：将应用程序分为多个独立的进程，在同一时刻运行

优点：可以使用远程链接的方式；

​			在进程间提供附加的保护操作和更高级别的通信机制，更容易编写安全的并发代码

缺点：需要的固定开销大

### 多线程并发

概念：在单个进程中运行多个线程。进程中的所有线程都共享地址空间，并且所有线程访问到的大部分数据——全局变了仍然是全局的。进程之间共享内存，但是同一数据的内存地址在不同的进程中不同。

优点：开销远小于使用多个进程。

缺点：要确保每个线程所访问到的数据是一致的。

### 入门

```c++
#include <iostream>
#include <thread>		//①
void hello()			//②
{
    std::cout<<"Hello Concurrent World\n";
}
int main()
{
    std::thread t(hello);	   //③
    t.join();			     //④
}
```

管理线程的函数和类在<font color='red'>**thread**</font>中声明，而保护共享数据的函数和类在其他头文件中声明。

每个线程都必须有一个初始化函数，比如独立函数②。

对于应用程序来说，初始线程使main()，但是对于其他线程，可以在<font color='red'>**std::thread**</font>对象的构造函数中指定，如本例中③位置。

新的线程③启动之后，初始线程继续执行。如果它不等新线程结束，有可能在新线程开始之前就结束程序。

④调用join()，使调用线程等待与<font color='red'>**std::thread**</font>对象相关联的线程。

## 线程管理

c++线程库启动线程，可以归结为构造<font color='red'>**std::thread**</font>对象。

> //相当于声明了一个叫my_thread的函数，带有一个参数(函数指针没有参数并返回background_task对象的函数)，而非启动了一个线程。
>
> std::thread my_thread(background_task()); 	
>
> //正确方式
>
> std::thread my_thread((background_task()));
>
> std::thread my_thread{background_task()};  



