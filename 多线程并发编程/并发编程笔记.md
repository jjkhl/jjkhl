<h1 align="center">并发编程笔记</h1>

中文原书：[c++并发编程](c++并发编程.pdf)

原版英文：[C++ Concurrency in Action 2nd Edition-2019-英文版](C++ Concurrency in Action 2nd Edition-2019-英文版.pdf)

## 基础概念

### 并发

概念：单个系统同时执行多个独立的任务。

使用原因：关注点分离和性能。

> 关注点分离：通过将无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能性。
>
> 任务并行：将一个单个任务分成几部分，且各自并行运行，从而降低总运行时间。
>
> 可并行的方式：与其同时处理一个文件，不如酌情处理多个文件。

### 多进程并发

概念：将应用程序分为多个独立的进程，在同一时刻运行

优点：可以使用远程链接的方式；

​			在进程间提供附加的保护操作和更高级别的通信机制，更容易编写安全的并发代码

缺点：需要的固定开销大

### 多线程并发

概念：在单个进程中运行多个线程。进程中的所有线程都共享地址空间，并且所有线程访问到的大部分数据——全局变了仍然是全局的。进程之间共享内存，但是同一数据的内存地址在不同的进程中不同。

优点：开销远小于使用多个进程。

缺点：要确保每个线程所访问到的数据是一致的。

### 入门

```c++
#include <iostream>
#include <thread>		//①
void hello()			//②
{
    std::cout<<"Hello Concurrent World\n";
}
int main()
{
    std::thread t(hello);	   //③
    t.join();			     //④
}
```

管理线程的函数和类在<font color='red'>**thread**</font>中声明，而保护共享数据的函数和类在其他头文件中声明。

每个线程都必须有一个初始化函数，比如独立函数②。

对于应用程序来说，初始线程使main()，但是对于其他线程，可以在<font color='red'>**std::thread**</font>对象的构造函数中指定，如本例中③位置。

新的线程③启动之后，初始线程继续执行。如果它不等新线程结束，有可能在新线程开始之前就结束程序。

④调用join()，使调用线程等待与<font color='red'>**std::thread**</font>对象相关联的线程。

## 线程管理

### 启动线程

c++线程库启动线程，可以归结为构造<font color='red'>**std::thread**</font>对象。

> //相当于声明了一个叫my_thread的函数，带有一个参数(函数指针没有参数并返回background_task对象的函数)，而非启动了一个线程。
>
> std::thread my_thread(background_task()); 	
>
> //正确方式
>
> std::thread my_thread((background_task()));
>
> std::thread my_thread{background_task()};  

### 等待线程完成

将销毁程序的detach()替换为<strong style="color:red">join()</strong>：确保局部变量在线程完成后，才被销毁。

一个线程只能使用一次join()；

### 特殊情况下的等待

拷贝构造函数和拷贝赋值操作被标记为=delete，是为了不让编译器自动生成。直接对一个对象进行拷贝和赋值可能会弄丢已经加入的线程。

### 后台运行线程

detach()会让线程在后台运行，意味着主线程不能与之产生直接交互。

## 向线程函数传递参数

### 向线程函数传递参数

```c++
void f(int i,std::string const &s);
std::thread t(f,3,"hello");
```

**动态指针作为参数传递给线程**：

```c++
std::thread t(f,3,std::string(buffer));//避免悬垂指针
```

**传递一个直接引用而不是复制后的引用**

```c++
//std::ref——将参数转换为引用的形式
void update_data_for_widget(widget_id w,widget_data& data);
std::thread t(update_data_for_widget,w,std::ref(data));  
```

**移动操作可以将对象转换为可接受的类型**：std::move

执行线程的所有权可以在多个**std::thread**实例中互相转移，主要是**std::thread**实例的可移动且不可复制性。

> 不可复制：保证在同一个时间点，一个**std::thread**实例只能关联一个执行线程。
>
> 可移动性：让程序员决定哪个实例拥有实际执行线程的所有权

### 转移线程所有权

新线程所有权都需要转移，并且需要等待线程结束。

```c++
void some_function();
void some_other_function();
std::thread t1(some_function);//①
std::thread t2=std::move(t1);//②
t1=std::thread(some_other_function);//③
std::thread t3;//④
t3=std::move(t2);//⑤
t1=std::move(t3);//⑥ 赋值操作将程序崩溃，因为t1已经有关联的线程
```

②操作将t1的所有权转移给t2，之后t1和执行线程没有关联，执行some_function的函数现在与t2关联。

与一个临时**std::thread**对象相关的线程启动了③。因为所有者是一个临时对象—移动操作将会隐式调用，所以不显示使用**std::move**转移所有权。

④默认构造t3，与任何执行线程没有关联。

⑤将t2关联线程的所有权转移到t3中，因为t2是一个命名对象。⑤操作完成后，t1与执行some_other_function的线程相关联，t2与任何线程都无关联，t3与执行some_function的线程相关联。

### 运行时决定线程数量

std::hardware_concurrency()

### 识别线程

1. 调用std::thread对象的成员函数get_id()直接获取
2. 调用std::get_id()函数(位于<thread>头文件中)

## 线程之间共享数据

### 共享数据带来的问题

**条件竞争**

并发中竞争条件的形成，取决于一个以上线程的相对执行顺序，每个线程都抢着完成自己的任务。

> 解决方式：
>
> 1.对数据结构采取保护机制——确保只有进行修改的线程才能看到不变量被破坏时的中间状态，从其他访问线程角度来看，修改不是已经完成就是还没开始。
>
> 2.对数据结构和不变量的设计进行设计，修改完的结构必须能完成一系列不可分割的变化，也就是保证每个不变量保持稳定的结构，这就是所谓的无锁编程。

### 使用互斥量保护共享数据

头文件：<mutex>

使用实例化std::mutex创建互斥量，通过调用成员函数lock()上锁，unlock()进行解锁。 

std::lock_guard：在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证可一个已锁的互斥量总是会被正确的解锁。

```c++
#include<list>
#include<mutex>
#include<algorithm>
std::list<int> some_list;//①
std::mutex some_mutex;//②
void add_to_list(int new_value)
{
    std::lock_guard<std::mutex> guard(some_mutex);//③
    some_list.push_back(new_value);
}
bool list_contains(int value_to_find)
{
    std::lock_guard<std::mutex> guard(some_mutex);//④
    return std::find(some_list.begin(),some_list.end(),value_to_find)!=some_list.end();
}
```

全局变量some_list被全局互斥量some_mutex保护。add_to_list()和list_contains()使用，使得这两个函数中对数据的访问是互斥的。

大多数情况下，互斥量会与保护的数据放在同一个类中，而不是定义成全局变量。

> 面向对象的设计准则：放在一个类中的数据可以让它们联系在一起，也可对类的功能进行封装并进行数据保护。

**切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去**

### 死锁问题及解决方案

问题：由两个及以上的互斥量来锁定一个操作，或者线程之间互相等待

一般建议：总在互斥B之前锁住互斥量A。

std::lock可以一次性锁住多个的互斥量，并且没有死锁的风险。

**避免嵌套锁**：每个线程只能有一个锁，锁上就不会死锁。

**避免在持有锁时调用用户提供的代码**

**使用固定顺序获取锁**

**使用锁的层次结构**

### std::unique_lock

1. 可将std::adopt_lock作为第二参数传入构造函数，对互斥量进行管理。
2. 可将std::defer_lock作为第二参数传递，表明互斥量保持解锁状态

## 实践操作

参考网址：https://blog.csdn.net/qq_38231713/category_10001159.html

[多线程编程基础方式](./多线程编程基础方式.md)

### thread创建线程方式

* 包含头文件`<thread>`

* 写初始函数

* main中写代码

```c++
//初始函数创建线程
#include<thread>
#include<iostream>
using namespace std;
void myprint()
{
	cout << "线程开始执行" << endl;

	cout << "线程执行完毕" << endl;
}
int main()
{
	thread myjob(myprint);//创建线程，线程执行七点myprint()
   	   //myprint开始执行
	myjob.join();//阻塞主线程，让主线程等待子线程执行完毕
	//子线程执行完毕，主线程继续往前
	cout << "I Love China" << endl;
	return 0;
}

//创建类的方式创建线程
#include<iostream>
#include<thread>
using namespace std;
class Ta
{
  public:
  void operator()()
  {
    cout<<"线程开始"<<endl;

    cout<<"线程结束"<<endl;
  }
};
int main()
{
  Ta ta;
  thread mythread(ta);
  mythread.join();
  system("pause");
  return 0;
}

//lambda表达式创建线程
#include<iostream>
#include<thread>
using namespace std;

int main()
{
  auto lambdaThread=[]{
    cout<<"线程开始"<<endl;
    cout<<"线程结束"<<endl;
  };
  thread mythread(lambdaThread);
  mythread.join();
  system("pause");
  return 0;
}

//类中的函数创建线程
#include<iostream>
#include<thread>
using namespace std;
class Data
{
  public:
  void GetMsg(){}
  void SaveMsg(){}
};

int main()
{
  Data s;
   //第一个&意思是取址，第二个&意思是引用，相当于std::ref(s)
    //thread oneobj(&Data_::SaveMsh,s)传值也是可以的
    //在其他的构造函数中&obj是不会代表引用的，会被当成取地址
    //调用方式：对象成员函数地址，类实例，[成员函数参数]
//第二个参数可以传递对象s，也可以传递引用std::ref(s)或&s
//传递s，会调用拷贝构造函数在子线程中生成一个新的对象
//传递&，子线程中还是用的原来的对象，所以就不能detach，因为主线程运行完毕会把该对象释放掉
  thread one(&Data::GetMsg,&s);
  thread one(&Data::SaveMsg,&s);
  mythread.join();
  system("pause");
  return 0;
}
```
### 线程传参

#### 传递临时对象作为线程函数

```c++
//陷阱1
#include <iostream>
#include <thread>
using namespace std;

void myPrint(const int &i, char* pmybuf)
{
	//如果线程从主线程detach了
	//i不是mvar真正的引用，实际上值传递，即使主线程运行完毕了，子线程用i仍然是安全的，但仍不推荐传递引用
	//推荐改为const int i
	cout << i << endl;
	//pmybuf还是指向原来的字符串，所以这么写是不安全的
	cout << pmybuf << endl;
}

int main()
{
	int mvar = 1;
	int& mvary = mvar;
	char mybuf[] = "this is a test";
	thread myThread(myPrint, mvar, mybuf);//第一个参数是函数名，后两个参数是函数的参数
	myThread.join();
	//myThread.detach();
	
	cout << "Hello World!" << endl;
}

//陷阱2
#include <iostream>
#include <thread>
#include <string>
using namespace std;

void myPrint(const int i, const string& pmybuf)
{
	cout << i << endl;
	cout << pmybuf << endl;
}

int main()
{
	int mvar = 1;
	int& mvary = mvar;
	char mybuf[] = "this is a test";
	//如果detach了，这样仍然是不安全的
	//因为存在主线程运行完了，mybuf被回收了，系统采用mybuf隐式类型转换成string
	//推荐先创建一个临时对象thread myThread(myPrint, mvar, string(mybuf));就绝对安全了。。。。
	thread myThread(myPrint, mvar, mybuf);
	myThread.join();
	//myThread.detach();

	cout << "Hello World!" << endl;
}
```

总结：

* 传递int这种简单类型，推荐使用值传递，而不是引用
* 如果传递类对象，建议使用隐式类型转换

#### 线程id

获取方式：`std::this_thread::get_id()`

#### 传递类对象、智能指针作为线程参数

```c++
//3.1
#include <iostream>
#include <thread>
using namespace std;

class A {
public:
	mutable int m_i; //m_i即使实在const中也可以被修改
	A(int i) :m_i(i) {}
};

void myPrint(const A& pmybuf)
{
	pmybuf.m_i = 199;
	cout << "子线程myPrint的参数地址是" << &pmybuf << "thread = " << std::this_thread::get_id() << endl;
}

int main()
{
	A myObj(10);
	//myPrint(const A& pmybuf)中引用不能去掉，如果去掉会多创建一个对象
	//const也不能去掉，去掉会出错
	//即使是传递的const引用，但在子线程中还是会调用拷贝构造函数构造一个新的对象，
	//所以在子线程中修改m_i的值不会影响到主线程
	//如果希望子线程中修改m_i的值影响到主线程，可以用thread myThread(myPrint, std::ref(myObj));
	//这样const就是真的引用了，myPrint定义中的const就可以去掉了，类A定义中的mutable也可以去掉了
	thread myThread(myPrint, myObj);
	myThread.join();
	//myThread.detach();

	cout << "Hello World!" << endl;
}

//3.2
#include <iostream>
#include <thread>
#include <memory>
using namespace std;

void myPrint(unique_ptr<int> ptn)
{
	cout << "thread = " << std::this_thread::get_id() << endl;
}

int main()
{
	unique_ptr<int> up(new int(10));
	//独占式指针只能通过std::move()才可以传递给另一个指针
	//传递后up就指向空，新的ptn指向原来的内存
	//所以这时就不能用detach了，因为如果主线程先执行完，ptn指向的对象就被释放了
	thread myThread(myPrint, std::move(up));
	myThread.join();
	//myThread.detach();

	return 0;
}

//3.3
#include <iostream>
#include <thread>
#include <vector>
using namespace std;

class A
{
public:
	int m_i;
	A(int a) :m_i(a) { cout << "构造函数执行" << this << "thread id:" << std::this_thread::get_id() << endl; }
	A(const A &a) :m_i(a.m_i) { cout << "拷贝构造函数执行" << this << "thread id:" << std::this_thread::get_id() << endl;}
	~A() { cout << "析构函数执行" << this << "thread id:" << std::this_thread::get_id() << endl;}

	//子线程入口
	void thread_work(int num)
	{
		cout << "子线程thread_work执行" << this << "thread id:" << std::this_thread::get_id() << endl;
	}
};

int main()
{
	A myobj(10);
    //注意这个构造函数的调用方法
	std::thread mytobj(&A::thread_work, myobj, 15);	//类成员函数指针，类对象，子线程参数
	mytobj.join();

	return 0;
}

/*运行结果

构造函数执行				005BF7B8		thread id:8160
拷贝构造函数执行		  	00B6E89C		thread id:8160
子线程thread_work执行		00B6E89C		thread id:27864
析构函数执行				00B6E89C		thread id:27864
析构函数执行				005BF7B8		thread id:8160

*/
```

