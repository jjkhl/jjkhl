<h1 align="center">并发编程笔记</h1>
中文原书：[c++并发编程](c++并发编程.pdf)

原版英文：[C++ Concurrency in Action 2nd Edition-2019-英文版](C++ Concurrency in Action 2nd Edition-2019-英文版.pdf)

## 基础概念

### 并发

概念：单个系统同时执行多个独立的任务。

使用原因：关注点分离和性能。

> 关注点分离：通过将无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能性。
>
> 任务并行：将一个单个任务分成几部分，且各自并行运行，从而降低总运行时间。
>
> 可并行的方式：与其同时处理一个文件，不如酌情处理多个文件。

### 多进程并发

概念：将应用程序分为多个独立的进程，在同一时刻运行

优点：可以使用远程链接的方式；

​			在进程间提供附加的保护操作和更高级别的通信机制，更容易编写安全的并发代码

缺点：需要的固定开销大

### 多线程并发

概念：在单个进程中运行多个线程。进程中的所有线程都共享地址空间，并且所有线程访问到的大部分数据——全局变了仍然是全局的。进程之间共享内存，但是同一数据的内存地址在不同的进程中不同。

优点：开销远小于使用多个进程。

缺点：要确保每个线程所访问到的数据是一致的。

### 入门

```c++
#include <iostream>
#include <thread>		//①
void hello()			//②
{
    std::cout<<"Hello Concurrent World\n";
}
int main()
{
    std::thread t(hello);	   //③
    t.join();			     //④
}
```

管理线程的函数和类在<font color='red'>**thread**</font>中声明，而保护共享数据的函数和类在其他头文件中声明。

每个线程都必须有一个初始化函数，比如独立函数②。

对于应用程序来说，初始线程使main()，但是对于其他线程，可以在<font color='red'>**std::thread**</font>对象的构造函数中指定，如本例中③位置。

新的线程③启动之后，初始线程继续执行。如果它不等新线程结束，有可能在新线程开始之前就结束程序。

④调用join()，使调用线程等待与<font color='red'>**std::thread**</font>对象相关联的线程。

## 线程管理

### 启动线程

c++线程库启动线程，可以归结为构造<font color='red'>**std::thread**</font>对象。

> //相当于声明了一个叫my_thread的函数，带有一个参数(函数指针没有参数并返回background_task对象的函数)，而非启动了一个线程。
>
> std::thread my_thread(background_task()); 	
>
> //正确方式
>
> std::thread my_thread((background_task()));
>
> std::thread my_thread{background_task()};  

### 等待线程完成

将销毁程序的detach()替换为<strong style="color:red">join()</strong>：确保局部变量在线程完成后，才被销毁。

一个线程只能使用一次join()；

### 特殊情况下的等待

拷贝构造函数和拷贝赋值操作被标记为=delete，是为了不让编译器自动生成。直接对一个对象进行拷贝和赋值可能会弄丢已经加入的线程。

### 后台运行线程

detach()会让线程在后台运行，意味着主线程不能与之产生直接交互。

## 向线程函数传递参数

### 向线程函数传递参数

```c++
void f(int i,std::string const &s);
std::thread t(f,3,"hello");
```

**动态指针作为参数传递给线程**：

```c++
std::thread t(f,3,std::string(buffer));//避免悬垂指针
```

**传递一个直接引用而不是复制后的引用**

```c++
//std::ref——将参数转换为引用的形式
void update_data_for_widget(widget_id w,widget_data& data);
std::thread t(update_data_for_widget,w,std::ref(data));  
```

**移动操作可以将对象转换为可接受的类型**：std::move

执行线程的所有权可以在多个**std::thread**实例中互相转移，主要是**std::thread**实例的可移动且不可复制性。

> 不可复制：保证在同一个时间点，一个**std::thread**实例只能关联一个执行线程。
>
> 可移动性：让程序员决定哪个实例拥有实际执行线程的所有权

### 转移线程所有权

新线程所有权都需要转移，并且需要等待线程结束。

```c++
void some_function();
void some_other_function();
std::thread t1(some_function);//①
std::thread t2=std::move(t1);//②
t1=std::thread(some_other_function);//③
std::thread t3;//④
t3=std::move(t2);//⑤
t1=std::move(t3);//⑥ 赋值操作将程序崩溃，因为t1已经有关联的线程
```

②操作将t1的所有权转移给t2，之后t1和执行线程没有关联，执行some_function的函数现在与t2关联。

与一个临时**std::thread**对象相关的线程启动了③。因为所有者是一个临时对象—移动操作将会隐式调用，所以不显示使用**std::move**转移所有权。

④默认构造t3，与任何执行线程没有关联。

⑤将t2关联线程的所有权转移到t3中，因为t2是一个命名对象。⑤操作完成后，t1与执行some_other_function的线程相关联，t2与任何线程都无关联，t3与执行some_function的线程相关联。

### 运行时决定线程数量

p2.4
