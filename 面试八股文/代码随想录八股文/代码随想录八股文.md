# C++

## C++基础

### 指针与引用

指针存放某个对象的地址，其本身就是变量，本身有地址，所以可以有指向指针的指针；可变，包括其所指向地址的改变和其指向地址中存放数据的改变。

引用就是变量的别名，也是指针常量，即值可变但是地址不可变，必须初始化。

不存在指向空值的引用，但是存在指向空值的指针。

#### const关键字

作用：被修饰的值是只读变量。必须在定义时就给予初值。

口诀：**左定值，右定向**（const在`*`的左侧还是右侧）

#### 常量指针

定义的指针指向只读对象，只能改地址不能改值。

形式：`const int* p=&temp`或`int const* p=&temp`

#### 指针常量(引用)

指针值定义时初始化，只能改值不能改地址。

形式：`int *const p=&temp`

### define和typedef、inline区别

> c++编译的4个阶段：`预处理生成` `.i`文件；`编译`生成汇编语言文件；``汇编`生成执行汇编语言文件；`链接`把各汇编文件链接组织起来成为可执行文件。

#### define

* 只是简单的字符串替换，没有类型检查
* 在编译的预处理阶段起作用
* 可以防止头文件重复引用
* 不分配内存，有多少次使用就进行多少次替换

#### typedef

* 有对应的数据类型，需要进行判断
* 在编译、运行的时候起作用
* 静态存储区分配空间，在程序运行过程中内存中只有一份拷贝

#### inline

* 先将内联函数编译完成生成了函数体直接插入到被调用的地方，减少了压栈、跳转和返回的操作。无普通函数调用时的额外开销。

> C/C++函数调用的开销：函数传递参数的拷贝开销；上一个调用函数的上下文保存。

* 特殊的函数，会进行类型检查
* 是对编译器的一种请求，编译器可能会拒绝该请求
* 限制：
  * 不能存在任何形式的循环语句
  * 不能存在过多的条件判断语句
  * 函数体不能过于庞大
  * 内敛函数声明必须在调用语句之前
  
### override和overload

####  override

override只是重写了一个方法以实现不同的功能，一般用于子类在继承父类时，重写父类方法。

规则：

* 重写方法的参数列表、返回值、所抛出的异常与重写方式一致
* 被重写的方法不能设置为private
* 静态方法不能重写为非静态
* 重写方法的访问修饰符一定要大于被重写方法的访问修饰符(public>protected>default>private)

#### overload

overload：一个方法有不同版本，存在于一个类中。

规则：

* 不能通过访问权限、返回类型、抛出异常进行重载
* 不同的参数类型可以是不同的参数类型、不同的参数个数、不同的参数顺序(参数类型必须不一样)
* 方法的异常类型和数目不会对重载造成影响

**使用多态是为了避免父类里大量重载引起代码臃肿且难于维护**

**重载和重写的本质区别是，加入了override修饰符的方法，此方法始终只有一个被使用的方法**

### new和malloc

* new内存分配失败时，会抛出bac_alloc异常，不会返回NULL；malloc分配内存失败会返回NULL
* 使用new操作符申请内存分配时无需指定内存的大小，malloc需要显式指出所需内存的尺寸
* operator new/operator delete可以被重载，malloc/free不可以被重载
* new/delete会调用对象的构造/析构函数，malloc不会
* new/delete是C++运算符，malloc/free是C++/C的标准库函数
* new/delete放回定义时具体类型的指针，malloc/free返回void类型指针
* new操作符从自由存储区上为对象动态分配内存空间，malloc从堆上动态分配

> 自由存储区是C++中通过new/delete动态分配和释放对象的存储区，是一个抽象概念；堆是操作系统维护的一块内存，是一个物理概念。

### constexpr和const

* constexpr表示“只读常量”，const表示“只读变量”，
* constexpr只能定义编译期常量，const还可以定义运行期常量
* 成员函数或变量定义为constexpr，则一定为const；反之则不一定成立。

#### constexpr变量

复杂系统中很难分辨一个初始值是否常量表达式，可以将变量声明为constexpr类型，由编译器在编译阶段验证变量的值是否是一个常量表达式。

必须使用常量初始化：

```c++
constexpr int n-20;
constexpr int m=n+1;
static constexpr int MOD=10000007;
```

如果constexpr声明中定义了一个指针，constexpr只对指针有效，相当于指针常量(引用)

```c++
constexpr int* p=NULL;
//相当于引用
int *const q=NULL;
```

#### constexpr函数

constexpr函数指能用于常量表达式的函数。

函数的返回类型和所有形参类型都是字面值类型，函数体有且只有一条return语句。

```c++
constepxr int new() {return 42;}
```

为了可以在编译过程中展开，constexpr函数被隐式转换为了内敛函数。

constexpr和内敛函数可以在程序中多次定义，一般定义在头文件。

#### constexpr构造函数

constexpr构造函数指字面值常量类的构造函数。必须要有一个空的函数体，即所有成员变量的初始化都是用初始化列表，对象调用的成员函数必须使用constexpr修饰。

#### [const](#const关键字)

要修改const修饰的变量的值，需要加上关键字`volatile`

要修改const成员函数中某些与类状态无关的数据成员，可以使用`mutable`关键字来修饰这个数据成员

------

const与static区别

| 关键字 | 修饰常量[非类中]                                             |                         修饰成员变量                         |                         修饰成员函数                         |
| :----: | ------------------------------------------------------------ | :----------------------------------------------------------: | :----------------------------------------------------------: |
| const  | 超出其作用域后空间会被释放；在定义时必须初始化，之后无法修改；const形参可以接收const和非const实参； | 只在某个对象的生命周期内是常量，对整个对象而言是可变的；不能赋值，不能在类外定义；只能通过构造函数的`参数初始化列表`初始化（因为不同对象对其const数据成员的值不同） | 防止成员函数修改对象内容；const对象不可以调用非const对象，但是非const对象可以调用const对象。 |
| static | 在函数执行后不会释放其存储空间。                             |      只能用在类定义体内部的声明，外部初始化且不加static      | 作为类作用域的全局函数(不能访问非静态数据成员和成员函数)；无this指针(不能直接存取非静态成员，调用非静态成员函数)；不能声明为virtual |

**const和static不能同时修饰成员函数原因：**静态成员函数无this指针，即不能实例化；而const成员必须集体到某一实例。

------

#### constexpr好处

* 保障一些不能修改的数据，避免变量被意外修改的风险。
* 某些情况下，编译器可以在编译阶段对constexpr代码进行优化，提高效率
* 相对宏，无额外开销，同时更加安全可靠

### volatile

定义：[与const绝对对立，是类型修饰符]影响编译器编译的结果。用该关键字声明的变量随时可能发生变化，与该变量有关的运算，不要进行编译优化；从内存中重新装载内容，而不是从寄存器拷贝内容。

```c++
volatile int i=10;
int a=i;
int b=i;
```

> [编译优化](https://zhuanlan.zhihu.com/p/62060524)：编译器发现两次从i读数据之间的代码没有对i进行操作，就会自动把上次度的数据放入b中，而不是从存放i的内存中读取。

作用：指令关键字，确保本条指令不会因编译器优化而忽略，且要求每次直接读值，保证对特殊地址的稳定访问

使用场合：在中断服务程序和CPU相关寄存器的定义

举例：

```c++
//空循环
for(volatile int i=0;i<1000;i++);
```

### extern

定义：声明外部变量[在函数或者文件外部定义的全局变量]

#### 前置++和后置++

后置++会创建临时对象，前置++不会所以可以返回引用，所以不会到来构造和析构的额外开销

### std::atomic

问题：a++和int a=b在C++中是否线程安全？

答案：不是。

**示例1**：

a++：从C/C++语法级别来看，这一条原子级别的语句；但从编译器得到的汇编指令来看，则不是原子级别，一般对应三条指令：首先将变量a对应的内存之搬运到某个寄存器中，然后将该寄存器中的值自增1，再将该寄存器中的值搬回a代表的内存中。

现假设i=0，有两个线程，每个线程对a的值都递增1，其结果应该是2，但是实际运行起来可能为1。

原因：操作系统线程调度的不确定性，线程1执行完步骤1和2后，寄存器中的值为1，此时操作系统切换到线程2执行，执行步骤1、2和3，此时寄存器中值变为1；接着操作系统回到线程1继续执行，得到a的最终结果为1.

**示例2：**

`int a=b;`：从C/C++语法级别看，这是一条原子级别的语句；但从编译器得到的汇编指令来看，由于目前计算机CPU架构体系的限制，数据不能直接从内存某处搬运到内存另外一处，必须借助寄存器中转。因此这条语句一般对应链条计算机指令，即将变量b的值搬运到某个寄存器，再从该寄存器搬运到变量a的内存地址中。

既然是两条指令，那么多个线程在执行这两条指令时，某个线程可能会在第一条指令执行完毕后被剥夺CPU时间片，切换到另一个线程而出现不确定的情况。

**解决方法：**C++11新标准提供了对整型变量原子操作的相关库，即`std::atomic`。

模板类型：

```c++
template<class T>
struct atomic;
//传入具体的整型类型对模板进行实例化
//初始化
std::atomic<int> value;
value=99;

//初始化2
//下面代码无法在Linux平台上无法编译通过(指在gcc编译器)
std::atomic<int> value=99;
/*
出错原因：这行代码调用过的是std::atomic的拷贝构造函数
而根据C++11语言规范，std::atomic拷贝构造函数调用=delete标记禁止编译器自动生成
g++在这条规则上遵循了C++11语言规范
*/
```

## C++三大特性

### 继承

| 基类成员属性 | public    | protected | private |
| ------------ | --------- | --------- | ------- |
| 公有继承     | public    | protected | 不可见  |
| 保护继承     | protected | protected | 不可见  |
| 私有继承     | private   | private   | 不可见  |

访问权限介绍：

* public：可以被任意实体访问
* protected：只允许子类及本类的成员函数访问
* private：只允许本类的成员函数访问

常见继承的方式：

* 实现继承：指使用基类的属性和方法而无需额外编码的能力
* 接口继承：指只使用属性和方法的名称、但是子类必须提供实现的能力
* 可视继承：指子类使用基类的外观和实现代码的能力

### 封装

把客观事物封装为抽象的类，并且类可以把自己的数据和方法只让信任的类或对象操作，对不可信的进行信息隐藏。

### 多态

向不同对象发送同一消息，不同对象在接收时会产生不同的行为。（重载实现编译时多态，虚函数实现运行时多态）

多态性：允许将子类类型的指针赋值给父类类型的指针

实现多态的两种方式：

* 覆盖(override)：子类重新定义父类的虚函数的做法
* 重载(overload)：允许存在多个同名函数，而这些函数的参数表不同

### 虚函数

当基类希望派生类定义适合自己的版本，就将这些函数声明为虚函数(virtual)

* 虚函数是动态绑定的：使用虚函数的指针和引用能够正确找到实际类的对应函数，而不是执行定义类的函数
* 多态：不同继承关系的类对象，调用同一函数产生不同行为
  * 调用函数对象必须是指针或引用
  * 被调用的函数必须是虚函数，且完成了虚函数的重写
* 动态绑定的是动态类型：所对应的函数或属性依赖于对象的动态类型，发生在运行期
* 构造函数不能是虚函数：构造函数实际执行父类对应函数，因为自己还没构造好
* 虚函数依赖虚函数表工作：虚函数表用来保存虚函数地址，当用基类指针指向派生类，虚表指针指向派生类的虚函数。(该机制保证派生类中的虚函数被调用)
* 析构函数可以是虚函数和纯虚函数
* 将一个函数定义为纯虚函数：将这个类定义为抽象类，不能实例化对象；纯虚函数通常没有定义体。
* inline、static、constructor三种函数不能带有virtual关键字
  * inline是在编译时展开，必须要有实体
  * static必须要有实体，static成员没有this指针，而virtual一定要通过对象来调用
* 派生类的override虚函数定义必须和父类完全一致

------

为什么要使用虚继承：

* 解决多继承时的命名冲突和冗余数据为题
* 让某个类做出声明，承诺愿意共享其基类

### 空类

* 空类大小为1：因为类的实例化是在内存中分配一块地址，每个实例在内存中都有独特的地址，而空类也会进行实例化。

```c++
class A{virtual void f();};
class B:public A{};
//A和B都不是空类，有虚函数表地址，其中A继承了B的虚函数表地址
//所以sizeof(A)=sizeof(B)=8

class A{};
class B:public virtual A{};
//A是空类，B不是空类(有指向虚基类的指针),所以sizeof(A)=1，sizeof(B)=8

class Father1{};class Father2{};
class Child:Father1,Father2{};
//三个都是空类，所以大小都为1
```

共享虚函数地址表：如果派生类继承的第一个是基类，且该基类定义了虚函数地址表，则派生类就共享该表首址占用的存储单元。

除了共享虚函数地址表以外的任何场景，派生类在处理完所有基类或虚基类后，根据派生类是否建立了虚函数地址表，确定是否为该表首址分配存储单元。

```c++
class X{};//sizeof(X)=1
class Y:public virtual X{};//sizeof(Y)=4(32位)	8(64位)
class Z:public virtual X{};//sizeof(Z)=4(32位)	8(64位)
class A:public virtual Y{};//sizeof(A)=8(32位)	8(64位)

//B内部继承了Y和Z的虚基类指针，同时对空类进行了优化，节省了它的1byte。
class B:public Y,public Z{};//sizeof(B)=8(32位)	16(64位)
class C:public virtual Y,public virtual Z{};//sizeof(C)=12(32位)	16(64位)

class D:public virtual C{};//sizeof(D)=16(32位)	16(64位)
```

## 智能指针

### 专有指针unique_ptr

```cpp
#include<memory>
//初始化方式一
unique_ptr<int> p1(new int(10));
//方式二也可以先定义一个未初始化的指针，然后再赋值
unique_ptr<int> p2;
p2=unqiue_ptr<int> (new int);
*p2=10;
//方式三
unique_ptr<int> p1(new int);
*p1=10;
//c++14后有工厂函数make_unique在创建智能指针时强制初始化
auto p3=make_unique<int>(42);
//make_unique类似模板
template<class T,class... Args>//可变参数模板
std::unique_ptr<T>//返回的智能指针
my_make_unique(Arg&&... args)//可变参数模板的入口参数
{
    return std::unique_ptr<T>(
        new T(std::forward<Args>(args)...);//"完美转发"
    )
}
```

* unique_ptr所有权唯一。必须使用`std::move`显示声明所有权转移，此时原来的unique_ptr变成了空指针。
* 如果定义类时将`unique_ptr`作为成员，那么类本身也是不可复制的。也就是说，unique_ptr会将它“唯一所有权”特性传递给它的持有者。

<h5 align="center">unique_ptr成员函数</h5>

|   成员函数    | 描述                                                         |
| :-----------: | :----------------------------------------------------------- |
|     move      | 转移所有权                                                   |
|     reset     | 销毁由该智能指针管理的任何可能存在的对象。该智能指针被置为空 |
| reset(T* ptr) | 销毁由该智能指针当前管理的任何可能存在的对象。该智能指针继续控制由裸指针 ptr 指向的对象 |
|     get()     | 返回该智能指针管理的由裸指针指向的对象。如果某个指针需要传递给函数，但是 该函数并不知道该如何操作智能指针，则 get() 函数非常有用 |
|    release    | 放弃对它所指对象的控制权，并返回保存的指针，将指针置为空，不会释放内存 |

* release会返回之前的指针，但不会释放内存；reset会释放内存

```cpp
// 将所有权从p1转移给p2
unique_ptr<string> p1(new string("abc"));
unique_ptr<string> p2(p1.release());   // p1.release()会将p1置空，并返回所指向的指针,此时*p2="abc";

unique_ptr<string> p3(new string("dfseg"));
// 将所有权从p3转移给p2
p2.reset(p3.release());  
// p3置空，并返回指针
// p2释放原来指向的对象，并重新指向p3的指针,*p2="dfseg"
//示例网址：https://blog.csdn.net/readyone/article/details/112297215
```

* 值传递需要使用`move()`，引用传递不需要

```cpp
//函数使用通过值传递的形参
void fun1(unique_ptr<int> uptrParam)
{
    cout << *uptrParam << endl;
}
//函数使用通过引用传递的值
void fun2(unique_ptr<int>& up)
{
    cout<<*up<<endl;
}
int main()
{
    unique_ptr<int> uptr(new int);
    *uptr = 10;
    fun1(move (uptr)); // 在调用中使用 move
    fun2(uptr);
}
```

### 共享指针shared_ptr

与`unique_ptr`最大区别在于：它的所有权可以被安全共享，即支持复制赋值，允许被多个同时拥有。

```cpp
auto p1=make_shared<int>(2);
shared_ptr<int> p1(new int(10));
//use_count()函数判断指针所有权
//p1.use_count()=1
auto p2=p1;
//p1.use_count()=2
//p2.use_count()=2
```

* shared_ptr能支持安全共享在于其内部使用了引用计数，最开始引用计数为1，表示只有一个持有者，如果发生复制赋值，也就是共享的时候，引用计数就会增加，而发生析构时，引用计数就会减少。只有当引用计数为0时，shared_ptr才会真正调用delete来释放内存。
* 同一指针不能同时为多个shared_ptr对象进行赋值

```c++
int* ptr = new int;
std::shared_ptr<int> p1(ptr);
std::shared_ptr<int> p2(ptr);//错误
```

* 在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。

```
//指定 default_delete 作为释放规则
std::shared_ptr<int> p6(new int[10], std::default_delete<int[]>());

//自定义释放规则
void deleteInt(int*p) {
	delete []p;
}
//初始化智能指针，并自定义释放规则
std::shared_ptr<int> p7(new int[10], deleteInt);

//或者借助lambda表达式
std::shared_ptr<int> p7(new int[10],[](int* p){delete[] p;})
```

* [boost文档结论](http://www.zzvips.com/article/126621.html)：同一个shared_ptr被多个线程读是安全的，同一个shared_ptr被多个线程写是不安全的，不同shared_ptr被多个线程写是安全的。[证明](https://www.freesion.com/article/1419746505/)：在多个线程中同时对一个shared_ptr循环执行两遍swap（swap函数作用是与另外一个shared_ptr交换引用对象或引用计数，是写操作。执行两遍swap之后，shared_ptr引用的对象的值应该不变）
* 参考网址(http://c.biancheng.net/view/7898.html)

<h5 align="center">shared_ptr<T>模板类常用成员函数</h5>

|  成员函数   | 描述                                                         |
| :---------: | :----------------------------------------------------------- |
|   swap()    | 交换2个相同类型shared_ptr指针的内容                          |
|   reset()   | 当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1 |
|    get()    | 获得shared_ptr对象内部包含的普通指针                         |
| use_count() | 返回同当前shared_ptr对象(包含它)指向相同的所有shared_ptr对象的数量 |
|  unique()   | 判断当前shared_ptr对象指向的堆内存，是否不再有其它shared_ptr对象指向它 |

### 弱引用指针weak_ptr

* 一般与`shared_ptr`类型指针搭配使用，当`weak_ptr`类型指针指向和某`shared_ptr`指针相同时，`weak_ptr `指针并不会使所指堆内存的引用计数加 1；同样，当` weak_ptr`指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，`weak_ptr` 类型指针并不会影响所指堆内存空间的引用计数。
* 当与shared_ptr指向相同内存，shared_ptr析构之后内存释放，在使用之前使用函数lock()检查weak_ptr是否为nullptr
* [成员函数](http://c.biancheng.net/view/7918.html)
<h5 align="center">weak_ptr成员函数</h5>

|成员函数|描述|
|:--:|:--|
|operator=()|重载`=`运算符，weak_ptr指针可以直接被weak_ptr或shared_ptr指针赋值|
|swap(x)|其中x表示同类型的weak_ptr指针，该函数可以互换2个同类型weak_ptr指针的内容|
|reset()|将当前weak_ptr指针置为空指针|
|use_count()|查看指向和当前weak_ptr指针相同的shared_ptr指针的数量|
|expired()|判断当前weak_ptr指针是否过期(指针为空，或指向的堆内存已经被释放)|
|lock()|    如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相同的 shared_ptr 指针。|
* weak_ptr一个重要用途就是让类正确的自我创建shared_ptr；对象内部用weak_ptr来保管this指针，然后调用lock()获取shared_ptr。
```c++
#include <iostream>
#include <memory>
using namespace std;
int main()
{
    std::shared_ptr<int> sp1(new int(10));
    std::shared_ptr<int> sp2(sp1);
    std::weak_ptr<int> wp(sp2);
    //输出和 wp 同指向的 shared_ptr 类型指针的数量
    cout << wp.use_count() << endl;//2
    //释放 sp2
    sp2.reset();
    cout << wp.use_count() << endl;//1
    //借助 lock() 函数，返回一个和 wp 同指向的 shared_ptr 类型指针，获取其存储的数据
    cout << *(wp.lock()) << endl;//10
    return 0;
}
```

## C++强制类型转换

### static_cast

**没有运行时类型检查来保证转换的安全性**

进行上行转换(把派生类的指针或引用转换为基类表示)是安全的。

进行下行转换，由于没有动态类型检查，所以是不安全的。

**使用：**

1. 用于基本数据类型之间的转换，如int转换为char
2. 把任何类型的表达式转换为void类型
3. static_cast不能转换掉expression的const、volatile、或者__unaligned属性

### dynamic_cast

* 在进行下行转换时，具有类型检查(信息在虚函数中)的功能，比static_cast更安全
* 转换后必须是类的指针、引用或void*，基类要有虚函数，可以交叉转换
* dynamic本身只能用于存在虚函数的父子关系的强制类型转换；对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常。

### reinterpret_cast

可以将整型转换为指针，也可以把指针转换为数组；可以在指针和引用里进行无限制的转换，平台移植性价比差。

### const_cast

常量指针转换为非常量指针，并且仍然指向原来的对象。常量引用被转换为非常量引用，并且仍然指向原来的对象，去掉类型的const或volatile属性。

## C++内存模式

### 字符串操作函数

#### strcpy()

把从strsrc地址开始且含有`\0`结束符的字符串复制到以strdest开始的地址空间，返回值类型为char*

```c++
char *strcpy(char* strDest,const char* strSrc)
{
    assert((strDest)&&(strSrc));
    char* address=strDest;
    while((*strDest++=*strSrc++)!='\0');
    return address;
}
```

### strlen()

计算给定字符串长度

```cpp
int strlen(const char* str)
{
    assert(str);//断言字符串地址非0
    int len;
    while((*str++)!='\0')
    {
        len++;
	}
    return len;
}
```

### strcat()

把src所指字符串添加到dest结尾处

```cpp
char* strcat(char* dest, const char* src)
{
    assert(dest&&src);
    char* ret=dest;
    while(*dest)
    {
        dest++;
    }
    while(*dest++=*src++){}
    return ret;
}
```

### strcmp()

比较两个字符串str1，str2

若str1==str2，返回0

若str1<str2，返回-1

若str1>str2，返回1

```cpp
int strcmp(const char* str1,const char* str2)
{
	assert(str1,str2);
    while(*str1&&*str2&&(*str1==*str2))
    {
        str1++;
        str2++;
    }
    return *str1-*str2;
}
```

### 内存泄漏

#### 定义

由于疏忽或错误造成了**程序未能释放掉不再使用得内存的情况**。内存泄漏并非指内存在物理上消失，而引用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

#### 内存泄漏分类

* 堆内存泄漏：程序员使用malloc、new等从堆中分配一块内存，但是完成后没有调用对应的free或delete删除，那么此块内存将不会被使用，就会产生堆内存泄漏。
* 系统资源泄漏：程序使用系统分配的资源比如SOCKET、handle等没有使用相应函数释放掉，导致系统资源浪费，严重可导致系统效能降低，系统运行不稳定。
* 没有将基类的析构函数定义为虚函数：当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄漏。

### 内存相关知识点

* 什么操作会导致内存泄漏：指针指向改变，未释放动态分配内存。

* 如何防止内存泄漏：将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；使用智能指针

* 构造函数、析构函数需要设为虚函数吗？

  * 构造函数不需要。虚函数调用是在部分信息完成工作的机制，允许我们只知道接口而不知道对象的确切类型。而要创建一个对象，需要知道对象的完整信息，特别是要创建的确切类型。
  * 析构函数需要。当派生类对象中有内存需要回收，如果析构函数不是虚函数，就不会触发动态绑定，只会调用基类析构函数，导致派生类资源无法释放，造成内存泄漏。

## 测试题目

### 字符串的相关函数补全

```cpp
class String
{
public:
	String(const char* str=NULL);
    /*
    拷贝构造：旧对象构造新对象
    */
	String(const String& other);
	~String(void);
    /*
    赋值构造：旧对象给另外一个旧对象赋值
    */
	String& operator=(const String& other);
private:
	char *m_data;
};
String::String(const char*str)
{
	if(str==NULL)
	{
		m_data=new char[1];//对空字符串自动申请存放结束标志'\0'
		*m_data='\0';
	}
	else
	{
		int len=strlen(str);
		m_data=new char[len+1];
		strcpy(m_data,str);
	}
}
String::~String(void)
{
	delete[] m_data;
}
String::String(const String& other)
{
	int len=strlen(other.m_data);
	m_data=new char[len+1];
	strcpy(m_data,other.m_data);
}
String &String::operator=(const String&other)
{
	if(this==&other)
	{
		return *this;//检查自赋值
	}
	delete[] m_data;//释放原有的内存资源
	int len=strlen(other.m_data);
	m_data=new char[len+1];
	strcpy(m_data,other.m_data);
	return *this;
}
```

### 进程的地址空间分布

![](./picture/进程空间分布.png)

如上图，从高地址到低地址，一个程序由命令行参数和环境变量、栈、文件映射区、堆、BSS段、数据段、代码段组成。

* 命令行参数和环境变量：命令行参数是指从命令行执行程序时给程序的参数
* 栈区：存储局部变量、函数参数值。栈从高地址向低地址增长，是一块连续的空间。
* 文件映射区：位于对合栈之间
* 堆区：动态申请内存。从低地址向高地址增长。
* BSS段：存放程序未初始化的全局变量和静态变量的一块内存区域
* 数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域
* 代码段：存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量

### C/C++的内存分配方式

* 从静态存储区域分配：内存在程序编译阶段已分配好，这块内存在程序的整个运行期间都存在，如全局变量，静态变量。
* 从栈上创建：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
* 从堆上动态分配：程序在运行的时候用malloc或new申请任意大小内存，程序员负责在何时free或delete释放内存。动态内存的生存期自己决定，非常灵活。

## 计算机中的乱序执行

* 一定会按正确顺序执行的情况
  * 对同一块内存进行访问，此时访问的顺序不会被编译器修改
  * 新定义的变量的值依赖于之前定义的变量，此时两个变量定义的顺序不会被编译器修改

* 其它情况计算机会进行乱序执行

  * 单线程的情况下允许，但是多线程情况下就会产生问题

* C++的六种内存模型：用于在多线程下防止编译器的乱序执行

  * memory_order_relaxed：最放松的
  * memory_order_consume：当客户使用，搭配release使用，被release进行赋值的变量y，获取的时候如果写成consume，那么所有与y有关的变量的赋值一定会被按顺序进行。
  * memory_order_acquire：获取资源
  * memory_order_release：一般用于生产者，当一个变量y进行赋值时，只有自己将这个变量释放了，别人才能去读，读的时候如果使用acquire来读，编译器会保证在y之前被赋值的变量在y之前被执行，相当于设置了内存屏障。
  * memory_order_acq_rel(acquire/release)
  * memory_order_seq_cst(sequentially consistent)

  好处：不需要编译器设置内存屏障，morden C++开始就由底层汇编能力

---

## C++ STL

### STL实现原理及其实现

六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器。

* 容器：各种数据结构，如vector、map等，用来存放数据，从实现角度来看，STL容器是一种class template
* 算法：各种常用的算法，如sort等。从实现角度来看，STL算法是一种function template
* 迭代器：扮演了容器和算法之间的胶合剂。原生指针也是一种迭代器。从实现角度来看，迭代器是一种`operator*、operator->、operator++、operetor--`等指针相关操作予以重载的class template。
* 仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了`operator()`的class或class template。
* 适配器：一种用来修饰容器或仿函数或迭代器接口的东西。比如queue和stack，他们底部完全借助deque，所有操作都由底层的deque实现。
* 空间配置器：负责空间的配置与管理。从实现角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。

**六大组件的交互关系：**

 * 容器通过空间配置器获取数据存储空间
 * 算法通过迭代器存储容器中的内容
 * 仿函数协助算法实现不同的策略变化
 * 适配器可以修饰仿函数

  **STL优点：**

* 高可重用性：SYL几乎所有代码采用了模板类或模板函数的方式实现，相比传统的由函数和类组成的库而言提供了更好的代码重用性。
* 高性能
* 高移植性
* 将数据和操作分离

###   vector

* 底层实现：在堆中分配了一段连续的内存空间来存放元素

* 三个迭代器：

  * first：起始字节位置，地址最小
  * last：最后一个元素的末尾字节位置，地址最大
  * end：指向容器的末尾字节

#### 扩容过程

如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，插入新增的元素。

所以对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。

**size()和capacity()**

* 队中分配内存，元素连续存放，内存空间只会增长不会减少
* 当capacity个size相等时，vector就会扩容，capacity翻倍变大

**固定扩容和加倍扩容区别：**

* 固定扩容

  * 优点：空间利用率较高
  * 缺点：固定扩容可能会面临多次扩容情况，时间复杂度较高

* 加倍扩容：

  * 优点：一次扩容翻倍的方式使得正常情况下添加元素需要扩容的次数大大较少，时间复杂度较低
  * 缺点：空间利用率较低

#### resize()和reserve()：

resize()：改变当前元素内含有元素的数量，不是容器容量。

* 当resize(len)中len>v.capacity()，则数组中size和capacity均设置为len
* 当len<=v.capacity()，则数组中的size设置为len，capacity则不变

reverse()：改变当前容器的最大容量

* 当reserve(len)的值>当前的capacity()，那么会重新分配一块能存len个对象的框架内，然后把之前的对象通过copy construtor复制过来并销毁之前的内存
* 当reverse(len)中len<=当前的capacity()，则不对容器做任何改变

### List

**list设计：**每个元素都是放在一块内存中，内存空间可以不连续，通过指针来进行数据的访问。

与list的区别：

* vector底层实现是数组；list是双向链表deque
* vector是顺序内存，支持随机访问；list不行
* vector在中间节点进行插入删除会导致内存拷贝；list不会
* vector一次性分配好内存，不够时才进行翻倍扩容；list每次插入新节点都会内存申请
* vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。

## C++泛型编程

### C++模板全特化和偏特化

对函数模板：

1. 模板和特例化版本应该声明在同一头文件，所有同名模板的声明应放在前面，接着是特例化版本
2. 一个模板被成为全特化的条件：必须有一个主模板类；模板类型被全部明确化

**模板函数**

```cpp
template<typename T1, typename T2>
void fun(T1 a,T2 b)
{
    cout<<"模板函数"<<endl;
}
template<>
void fun<int,char>(int a,char b)
{
    cout<<"全特化"<<endl;
}
```

函数模板只有全特化，偏特化功能通过函数重载完成。

**对类模板：**

```cpp
template<typename T1,typename T2>
class Test
{
public:
    Test(T1 i,T2 j):a(i),b(j){cout<<"模板类"<<endl;}
private:
    T1 a;
    T2 b;
};
template<>
class Test<int,char>
{
public:
    Test(int i,char j):a(i),b(j){cout<<"全特化"<<endl;}
private:
    int a;
    char b;
};
template<typename T2>
class Test<char,T2>
{
public:
    Test(char i,T2 j):a(i),b(j){cout<<"偏特化"<<endl;}
private:
    char a;
    T2 b;
};
```

对主版本模板类、全特化类、偏特化类的调用优先级从高排序：全特化类>偏特化类>主版本模板类

## C++11新特性

### lambda表达式

```cpp
[capture list](parameter list) -> return type {function body}
//[捕获列表](参数列表)->返回类型{函数体}
//只有捕获列表和函数体是必须的

auto lam=[]()->int{cout<<"hello"<<endl;return 88;};
auto ret=lam();
cout<<ret<<endl;
/*
->int：代表此匿名函数返回int
*/
```

**变量捕获：**

* []：不捕获任何变量，表达式内部不能访问外部变量
* [&]：引用方式捕获所有变量
* [=]：值的方式捕获所有变量(创建时拷贝，修改对lambda内对象无影响)
* [=,&foo]：引用捕获变量foo，其余变量靠值捕获
* [&,foo]：值捕获foo，其余变量靠引用
* [bar]：值捕获变量bar，不捕获其余变量
* [this]：捕获所在类的this指针

## 并发

### std::thread

| default(1)         | thread() noexcept;                                           |
| ------------------ | ------------------------------------------------------------ |
| initialization(2)  | template<class Fn, class… Args>explicit thread(Fn&& fn, Args&&… args); |
| `copy[deleted](3)` | thread(const thread&) =delete;                               |
| move(4)            | thread(thread&& x) noexcept;                                 |

1. 默认构造函数：创建一个空的thread执行对象
2. 初始化构造函数：创建一个thread对象，该thread对象可被joinable，新产生的
3. 拷贝构造函数(被禁用)：意味着thread不可被拷贝构造
4. move构造函数：调用成功之后x不代表任何thread执行对象

>  可被joinable的thread对象必须必须在他们销毁之前被主线程join或者将其设置为detached

## lock_guard

特点：

* 创建即加锁，作用域结束自动析构并解锁，无需手工解锁
* 不能中途解锁，必须等作用域结束才解锁
* 不能复制

### unique_lock

特点：

* 创建时可以不锁定(通过指定第二个参数为std::defer_lock)
* 可以随时加锁解锁
* 析构时自动释放锁
* 不可复制，可移动
* 条件变量需要该类型的锁作为参数(必须使用unique_lock)

# 计算机基础

## 操作系统

操作系统(Operating System)：介于硬件资源和应用程序之间的一个系统软件。负责管理硬件资源，为应用程序提供服务，同时管理应用程序。

功能：

* **资源分配，资源回收：**资源分配体现在CPU上，比如进程调度、内存分配、内存内外碎片问题等；资源回收考虑内存回收后的合并等。

* **为应用程序提供服务：**操作系统将硬件资源的操作封装起来，提供相对统一的接口(系统调用)供开发者调用。

* **管理应用程序：**控制进程的声明周期，进程开始时的环境配置和资源分配、进程结束后的资源回收、进程调度等。

* 操作系统内核的功能：

  * 进程调度：管理进程、线程，决定哪个进程、线程使用CPU
  * 内存管理：决定内存的分配和回收
  * 硬件通信：管理硬件，为进程和硬件之间提供通信
  * 系统调用：进行更高权限运行的服务

> 健壮性，也叫鲁棒性，即使很粗鲁对待程序，还是可以运行完美

### 操作系统的角色

**管理者：**CPU、内存、外村、IO，以及自己的健壮性和安全性。

**魔术师：**操作系统会让每个进程都觉得自己独占CPU、独占整片物理内存，而实际上每个进程都只是在某个时间段内占用CPU，仅仅只是占用实际一点点物理内存。

### 用户程序和操作系统的关系

> 相互调用

**操作系统角度：**计算机启动后的启动第一个软件就是操作系统，随后启动的所有进程都运行在操作系统上，使用操作系统提供的服务，同时被操作系统监控，进程结束后也由操作系统回收。

**进程角度：**调用操作系统提供的服务，实现自己的功能

## 进程

编译的代码可执行文件只是存储在硬盘的静态文件，运行时被加载到内存，CPU执行内存中指令，这个运行的程序被称为进程。

**进程是对运行程序的封装，操作系统进行资源调度和分配的基本单位。**

### 进程的实现

中断发生后操作系统底层的工作步骤：

1. 硬件压入堆栈程序计数器等
2. 硬件从中断向量转入新的程序计数器
3. 汇编语言过程保存寄存器值
4. 汇编语言过程设置新的队长
5. C中断服务例程运行(典型地读和缓冲输入)
6. 调度程序决定下一个将运行的进程
7. C过程返回至汇编代码
8. 汇编语言过程开始运行新的当前进程

**进程表：**

为了实现进程模型，操作系统维护着一张表格，即进程表。

 每个进程占有一个进程表项，该表项包含一个进程状态的重要信息，包括程序计数器、堆栈指针、内存分状况、所打开文件的状态、账号的调度信息，以及其它在进程由运行态转换到就绪态或阻塞态必须保存的信息，从而保证该进程随后能再次启动。

### 并发与并行

* 单个核心在很短时间内分别执行多个进程，称为并发
* 多个核心同时执行多个进程，称为并行
* 对于并发，CPU需要进程间的切换，这个过程需要保存进程的状态信息

### 进程的状态

分为运行态、就绪态、阻塞态。

比如read系统调用阻塞，进程会占用内存空间，这是一种浪费行为。于是操作系统会有跟内存管理中物理页置换到磁盘一样的行为，把**阻塞进程置换到磁盘中**，此时进程为占用物理内存，我们称之为**挂起**。

* 运行态：进程时刻占用CPU
* 就绪态：可运行，由于其它进程处于运行状态而暂时停止运行
* 阻塞态：该进程正在等待某一事件（如等待输入/输出操作的完成）而暂时停止运行。阻塞态进程占用物理内存，在虚拟内存管理的操作系统中，通常会把阻塞态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。
* 挂起态：描述进程没有占用实际的物理内存空间的情况
* 阻塞挂起状态：进程在外存(硬盘)，等待某个事件的出现
* 就绪挂起状态：进程在外存(硬盘)，但只要进入内存，马上运行

![image-20220725225637008](picture/进程状态图.png)

特点：

* 就绪态和运行态可以互相转换，其它都是单向转换。就绪态的进程通过调度算法获得CPU时间，转为运行态。
* 运行态的进程，在分配给它的CPU时间片用完后就会转为就绪状态，等待下一次调度。
* 阻塞态是缺少需要的资源从而由运行态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行态转为就绪态。

#### 进程控制块(PCB)

操作系统对进程的感知，是通过进程控制块PCB数据结构来描述的。它是进程存在的唯一标识，包括以下信息：

* **进程描述信息：**进程标识符、用户标识符等
* **进程控制和管理信息：**进程状态、进程优先度等
* **进程资源分配清单：**虚拟内存地址空间信息、打开文件列表、IO设备信息等
* **CPU相关信息：**当进程切换时，CPU寄存器的值都被保存在相应PCB中，以便CPU重新执行该进程时能从断点处继续痴心

PCB通过链表形式组织起来，比如由就绪队列、阻塞队列等，方便增删，方便进程管理。

#### 进程状态的切换

* 就绪态：等待被调度
* 运行态
* 阻塞态：等待资源

**转换关系：**

* 只有就绪态和运行态可以互相转换，其余都是单向
* 就绪态的进程通过调度算法从而获得CPU时间，转为运行态；而运行态的进程，在分配给它的CPU时间片完之后就会转为就绪状态，等待下一次调度
* 进程因为等待资源而阻塞，但是该资源不包括CPU时间，缺少CPU时间会从运行态转为就绪态
* 当进程等待的外部事件发生时，阻塞态就会转为就绪态；如果此时没有其它进程运行，便转换为运行态，否则该进程将处于就绪态，等待CPU空闲轮到它运行。

### 进程切换为什么比线程慢

参考网址：https://baijiahao.baidu.com/s?id=1717911727832372675&wfr=spider&for=pc

**进程切换涉及虚拟地址空间的切换而线程不会。**

**每个进程都有自己的虚拟地址空间，并且独立于其它进程的地址空间。**而线程时共享所在进程的虚拟地址空间，所以同一个线程中的线程进行线程切换时不涉及虚拟地址空间转换。

把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程(至少访问2次内存)，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个Cache就是TLB(快表)

每个进程都有自己的虚拟空间，显然每个进程都有自己的页表，但是CPU中的快表只有一个，页表切换后快表就是失效了，Cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行变慢。而线程切换不会导致快表失效，因为线程无需切换地址空间。

### 守护进程

守护进程：在后台运行的，没有控制中断与之相连的进程。它独立于控制终端，周期性执行某种任务。

> Linux大多数服务器就是用守护进程的方式实现的，如web服务器进程http等

**创建守护进程的要点：**

1. 让程序在后台执行：使用fork()产生一个子进程，然后使父进程退出
2. 调用`setsid()`创建一个新对话期：守护进程需要摆脱父进程的影响，方法是调用`setsid()`使进程成为一个会话组长。`setsid()`调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。
3. 禁止进程重新打开控制终端：经过上述1和2步骤，进程已为无终端的会话组长，但是还可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过fork()产生新的子进程，使调用fork的进程退出。
4. 关闭不再需要的文件描述符：子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。**方法：**首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值得所有文件描述符。
5. 将当前目录更改为根目录
6. 子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权：使用unmask(0)将屏蔽字清零。
7. 处理SIGCHLD信号：对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程成为僵尸进程，从而占用系统资源；如果父进程等待子进程结束，将增加父进程得负担，影响服务器进程得并发性能。在Linux下可以简单将SIGCHLD信号的操作设为SIG_IGN，这样子进程结束时不会产生僵尸进程。

### 僵尸进程

多进程程序，父进程一般需要跟踪子进程的信息，当子进程退出，父进程正在运行，子进程必须等到父进程捕获到子进程的退出状态才真正结束。在子进程结束后，父进程读取状态前，此时子进程为僵尸进程。

设置僵尸进程的目的时维护子进程的信息，以便父进程在某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU事件。所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。

但是子进程停止在僵尸态会占据内核资源，所以需要避免僵尸进程的产生或立即结束子进程的僵尸态。

* 父进程调用wait/waitpid等函数等待子进程结束，如果无子进程退出wait会导致父进程阻塞。waitpid只会等待pid指定的子进程，但是非阻塞，目标进程正常退出返回子进程PID，无则返回0。
* 在事件已经发生的情况下执行非阻塞调用可以提高程序效率。对waitpid，最好是在子进程退出后调用。使用SIGCHLD信号通知父进程，子进程结束。

> 父进程中捕获信号，然后在信号处理函数中调用waitpid以彻底结束子进程

### 多进程

进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。

父进程创建子进程之后，父子进程除了pid外，几乎所有部分几乎一样。

父、子进程共享全部数据，子进程在写数据时会使用写时复制计数将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作，而不是对同一块数据进行操作。

如果子进程想要运行自己的代码，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。

### 进程调度算法

* 批处理系统中的调度
  * 先来先到服务：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一致等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。
  * 最短作业优先：非抢占式调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。
  * 最短剩余时间优先：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。

* 交互式系统中的调度：

  * 时间片轮转调度：将所有就绪进程按照先来先服务的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的对位，同时继续把CPU时间分配给队首的进程。
  * 优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
  * 多级队列：设置了多个队列，每个队列时间片大小都不同，例如1、2、4、8、16…。进程在第一个队列没执行完，就会被转移到下一个队列。这种调度算法可以看作时间轮转调度算法和优先级调度算法的结合。
  * 最短进程优先：如果我们将每一条命令的执行看作一个独立的“作业”，则可以通过首先运行最短的作业来使响应时间最短。

### 进程通信

#### 通信的类型

* 同一主机：无名管道、有名管道、信号、消息队列、共享内存、信号量、存储映射
* 不同主机：socket

#### 无名管道

**特点：**

* 半双工，数据在同一时刻只能在一个方向上流动
* 数据只能从管道一端写入，另一端读出
* 写入管道的数据遵循先入先出规则
* 管道传输的数据是无格式的，这要求管道双方实现约定好数据格式。
* 管道不是普通的文件，不属于某个文件系统，只存在内存中对应的缓冲区。
* 从管道读数据是一次性操作，数据一旦被读走，就会被管道抛弃，释放空间以便写入更多数据
* 管道没有名字，只能在具有公共祖先的进程之间使用
* 存在阻塞方式

**pipe函数**

```cpp
#include<unistd.h>
int pipe(int pipefd[2]);
/*
fd[0]固定用作管道读端，fd[1]用作管道写端
成功返回0，失败返回-1
*/
```

**读写管道的四种进程情况**

* 第一种：
  * 如果写端没有关闭，管道没有数据，此时读管道进程去读管道就会阻塞
  * 如果写端没有关闭，管道中有数据，此时读管道进程就会读出数据，下一次读没有数据就会阻塞
* 第二种：管道所有写端关闭，读进程去读管道的内容，读取全部内容后，最后返回0
* 第三种：所有读端没有关闭，如果管道被写满了，写管道进程写管道会被阻塞
* 第四种：所有读端全部关闭，写管道进程写管道会受收到一个信号然后退出

**读管道：**

* 管道中有数据：read返回实际读到的字节数
* 管道中无数据：
  * 管道写端被全部关闭，read返回0(相当于读到文件结尾)
  * 管道写端没全部关闭，read阻塞等待

**写管道：**

* 管道读端全部被关闭：进程异常终止，也可以捕捉SIGPIPE信号使进程终止
* 管道读端没有全部被关闭：管道已满，write阻塞；管道未满，write将数据写入，并返回实际写入的字节数。

**查看管道缓冲区函数：**

```c++
#include<unistd.h>
long fpathconf(int fd, int name);
/*
通过name参数查看不容的属性值
name中有_PC_PIPE_BUF表示管道缓冲区大大小；_PC_NAME_MAX表示文件名字字节数上限
*/
```

**设置为非阻塞的方法**

```cpp
//获取原来的flags
int flags = fcntl(fd[0], F_GETFL);
//设置新的flags
flag |= O_NONBLOCK;
// flags = flags | O_NONBLOCK;
fcntl(fd[0], F_SETFL, flags);
```

#### 有名管道(FIFO)

与无名管道的不同在于：提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，通过FIFO不相关的进程也能交换数据。

**与无名管道的不同：**

* FIFO在文件系统作为一个特殊的文件而存在，但是FIFO的内容却放在内存
* 当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统以便以后使用
* FIFO有名字，不相关的进程可以通过打开命名管道进行通信

**通过命令创建有名管道：**mkfifo fifo;

**通过函数创建有名管道：**

```cpp
#include<sys/types.h>
#include<sys/stat.h>
int mkfifo(const char* pathname, mode_t mode);
/*
pathname：普通的路径名，也就是创建后FIFP的名字
mode权限：与open()函数的mode参数相同
成功返回0，失败返回-1
*/
```

#### 共享存储映射

存储映射I/O使一个磁盘文件与储存空间的一个缓冲区相映射。

当从缓冲区中读取数据，就相当于读文件中的相应字节；将数据存入缓冲区，则响应字节就自动写入文件。

共享内存是最有用的进程间通信方式，也是最快的进程间通信形式，因为进程可以直接读写内存，而不需要任何数据拷贝。

![image-20220727000426316](picture/共享存储映射.png)

**存储映射函数**

```c++
#include<sys/mman.h>
void *mmap(void* addr,size_t length,int prot,int flags,int fd,off_t offset);
/*
解释：一个文件或者其它对象映射进入内存。
addr：指定映射的起始位置，通常设置为NULL，由系统指定
length：映射到内存的文件长度
prot：映射区的保护方式，常用：读(PROT_READ)、写(PROT_WRITE)、读写(PROT_READ|PROT_WRITE)
flags：映射区特性，常用：MAP_SHARED(写入映射区的数据会复制回文件，且允许其它映射该文件的进程共享)；MAP_PRIVATE(对映射区的写入操作会产生一个映射区的复制，对此区域所作的修改不会写回源文件)
fd：由open返回的文件描述符，代表要映射的文件
offset：以文件开始处的偏移量，必须是4K的整数倍；通常为0，表示从文件头开始映射
成功返回创建的映射区首地址，失败返回MAP_FAILED宏
*/

int munmap(void* addr,size_t length);
/*
addr：使用mmap函数创建的映射区的首地址
length：映射区的大小
成功返回0，失败返回-1
*/
```

**注意事项：**

* 创建映射区的过程中，隐含着一次对映射文件的读操作
* 当MAP_SHARED时，要求：映射区的权限需要小于等于文件打开的权限(保护映射区)。而MAP_PRIVATE则无所谓，因为mmap的权限是对内存的限制。
* 映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。
* 当映射文件大小为0，不可创建映射区。
* munmap传入的地址一定是mmap的返回地址，坚决杜绝指针++操作。
* 文件偏移量必须是4K的整数倍
* mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。

**匿名映射实现父子进程通信：**

* 为什么要使用匿名的方式实现通信？

内存映射需要依赖文件，而建立文件建立好了之后还要[unlink close](https://www.cnblogs.com/zhaoyl/p/4043528.html#:~:text=unlink%E5%87%BD%E6%95%B0%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95%E9%A1%B9%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%87%8F%E5%B0%91%E4%B8%80%E4%B8%AA%E9%93%BE%E6%8E%A5%E6%95%B0%E3%80%82,%E5%A6%82%E6%9E%9C%E9%93%BE%E6%8E%A5%E6%95%B0%E8%BE%BE%E5%88%B00%E5%B9%B6%E4%B8%94%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E8%AF%A5%E6%96%87%E4%BB%B6%EF%BC%88close%E4%BA%86%E9%83%BD%EF%BC%89%EF%BC%8C%E8%AF%A5%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%89%8D%E8%A2%AB%E7%9C%9F%E6%AD%A3%E5%88%A0%E9%99%A4%E3%80%82)，比较麻烦。

* Linux系统无需依赖一个文件即可创建映射区，使用MAP_ANON(或MAP_ANONYMOUS)

> int *p =mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANON,-1,0);

