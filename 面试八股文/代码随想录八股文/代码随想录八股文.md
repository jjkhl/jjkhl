# C++

## C++基础

### 指针与引用

指针存放某个对象的地址，其本身就是变量，本身有地址，所以可以有指向指针的指针；可变，包括其所指向地址的改变和其指向地址中存放数据的改变。

引用就是变量的别名，也是指针常量，即值可变但是地址不可变，必须初始化。

不存在指向空值的引用，但是存在指向空值的指针。

#### const关键字

作用：被修饰的值是只读变量。必须在定义时就给予初值。

口诀：**左定值，右定向**（const在`*`的左侧还是右侧）

#### 常量指针

定义的指针指向只读对象，只能改地址不能改值。

形式：`const int* p=&temp`或`int const* p=&temp`

#### 指针常量(引用)

指针值定义时初始化，只能改值不能改地址。

形式：`int *const p=&temp`

### define和typedef、inline区别

> c++编译的4个阶段：`预处理生成` `.i`文件；`编译`生成汇编语言文件；``汇编`生成执行汇编语言文件；`链接`把各汇编文件链接组织起来成为可执行文件。

#### define

* 只是简单的字符串替换，没有类型检查
* 在编译的预处理阶段起作用
* 可以防止头文件重复引用
* 不分配内存，有多少次使用就进行多少次替换

#### typedef

* 有对应的数据类型，需要进行判断
* 在编译、运行的时候起作用
* 静态存储区分配空间，在程序运行过程中内存中只有一份拷贝

#### inline

* 先将内联函数编译完成生成了函数体直接插入到被调用的地方，减少了压栈、跳转和返回的操作。无普通函数调用时的额外开销。

> C/C++函数调用的开销：函数传递参数的拷贝开销；上一个调用函数的上下文保存。

* 特殊的函数，会进行类型检查
* 是对编译器的一种请求，编译器可能会拒绝该请求
* 限制：
  * 不能存在任何形式的循环语句
  * 不能存在过多的条件判断语句
  * 函数体不能过于庞大
  * 内敛函数声明必须在调用语句之前
  
### override和overload

####  override

override只是重写了一个方法以实现不同的功能，一般用于子类在继承父类时，重写父类方法。

规则：

* 重写方法的参数列表、返回值、所抛出的异常与重写方式一致
* 被重写的方法不能设置为private
* 静态方法不能重写为非静态
* 重写方法的访问修饰符一定要大于被重写方法的访问修饰符(public>protected>default>private)

#### overload

overload：一个方法有不同版本，存在于一个类中。

规则：

* 不能通过访问权限、返回类型、抛出异常进行重载
* 不同的参数类型可以是不同的参数类型、不同的参数个数、不同的参数顺序(参数类型必须不一样)
* 方法的异常类型和数目不会对重载造成影响

**使用多态是为了避免父类里大量重载引起代码臃肿且难于维护**

**重载和重写的本质区别是，加入了override修饰符的方法，此方法始终只有一个被使用的方法**

### new和malloc

* new内存分配失败时，会抛出bac_alloc异常，不会返回NULL；malloc分配内存失败会返回NULL
* 使用new操作符申请内存分配时无需指定内存的大小，malloc需要显式指出所需内存的尺寸
* operator new/operator delete可以被重载，malloc/free不可以被重载
* new/delete会调用对象的构造/析构函数，malloc不会
* new/delete是C++运算符，malloc/free是C++/C的标准库函数
* new/delete放回定义时具体类型的指针，malloc/free返回void类型指针
* new操作符从自由存储区上为对象动态分配内存空间，malloc从堆上动态分配

> 自由存储区是C++中通过new/delete动态分配和释放对象的存储区，是一个抽象概念；堆是操作系统维护的一块内存，是一个物理概念。

### constexpr和const

* constexpr表示“只读常量”，const表示“只读变量”，
* constexpr只能定义编译期常量，const还可以定义运行期常量
* 成员函数或变量定义为constexpr，则一定为const；反之则不一定成立。

#### constexpr变量

复杂系统中很难分辨一个初始值是否常量表达式，可以将变量声明为constexpr类型，由编译器在编译阶段验证变量的值是否是一个常量表达式。

必须使用常量初始化：

```c++
constexpr int n-20;
constexpr int m=n+1;
static constexpr int MOD=10000007;
```

如果constexpr声明中定义了一个指针，constexpr只对指针有效，相当于指针常量(引用)

```c++
constexpr int* p=NULL;
//相当于引用
int *const q=NULL;
```

#### constexpr函数

constexpr函数指能用于常量表达式的函数。

函数的返回类型和所有形参类型都是字面值类型，函数体有且只有一条return语句。

```c++
constepxr int new() {return 42;}
```

为了可以在编译过程中展开，constexpr函数被隐式转换为了内敛函数。

constexpr和内敛函数可以在程序中多次定义，一般定义在头文件。

#### constexpr构造函数

constexpr构造函数指字面值常量类的构造函数。必须要有一个空的函数体，即所有成员变量的初始化都是用初始化列表，对象调用的成员函数必须使用constexpr修饰。

#### [const](#const关键字)

要修改const修饰的变量的值，需要加上关键字`volatile`

要修改const成员函数中某些与类状态无关的数据成员，可以使用`mutable`关键字来修饰这个数据成员

------

const与static区别

| 关键字 | 修饰常量[非类中]                                             |                         修饰成员变量                         |                         修饰成员函数                         |
| :----: | ------------------------------------------------------------ | :----------------------------------------------------------: | :----------------------------------------------------------: |
| const  | 超出其作用域后空间会被释放；在定义时必须初始化，之后无法修改；const形参可以接收const和非const实参； | 只在某个对象的生命周期内是常量，对整个对象而言是可变的；不能赋值，不能在类外定义；只能通过构造函数的`参数初始化列表`初始化（因为不同对象对其const数据成员的值不同） | 防止成员函数修改对象内容；const对象不可以调用非const对象，但是非const对象可以调用const对象。 |
| static | 在函数执行后不会释放其存储空间。                             |      只能用在类定义体内部的声明，外部初始化且不加static      | 作为类作用域的全局函数(不能访问非静态数据成员和成员函数)；无this指针(不能直接存取非静态成员，调用非静态成员函数)；不能声明为virtual |

**const和static不能同时修饰成员函数原因：**静态成员函数无this指针，即不能实例化；而const成员必须集体到某一实例。

------

#### constexpr好处

* 保障一些不能修改的数据，避免变量被意外修改的风险。
* 某些情况下，编译器可以在编译阶段对constexpr代码进行优化，提高效率
* 相对宏，无额外开销，同时更加安全可靠

### volatile

定义：[与const绝对对立，是类型修饰符]影响编译器编译的结果。用该关键字声明的变量随时可能发生变化，与该变量有关的运算，不要进行编译优化；从内存中重新装载内容，而不是从寄存器拷贝内容。

```c++
volatile int i=10;
int a=i;
int b=i;
```

> [编译优化](https://zhuanlan.zhihu.com/p/62060524)：编译器发现两次从i读数据之间的代码没有对i进行操作，就会自动把上次度的数据放入b中，而不是从存放i的内存中读取。

作用：指令关键字，确保本条指令不会因编译器优化而忽略，且要求每次直接读值，保证对特殊地址的稳定访问

使用场合：在中断服务程序和CPU相关寄存器的定义

举例：

```c++
//空循环
for(volatile int i=0;i<1000;i++);
```

### extern

定义：声明外部变量[在函数或者文件外部定义的全局变量]

#### 前置++和后置++

后置++会创建临时对象，前置++不会所以可以返回引用，所以不会到来构造和析构的额外开销

### std::atomic

问题：a++和int a=b在C++中是否线程安全？

答案：不是。

**示例1**：

a++：从C/C++语法级别来看，这一条原子级别的语句；但从编译器得到的汇编指令来看，则不是原子级别，一般对应三条指令：首先将变量a对应的内存之搬运到某个寄存器中，然后将该寄存器中的值自增1，再将该寄存器中的值搬回a代表的内存中。

现假设i=0，有两个线程，每个线程对a的值都递增1，其结果应该是2，但是实际运行起来可能为1。

原因：操作系统线程调度的不确定性，线程1执行完步骤1和2后，寄存器中的值为1，此时操作系统切换到线程2执行，执行步骤1、2和3，此时寄存器中值变为1；接着操作系统回到线程1继续执行，得到a的最终结果为1.

**示例2：**

`int a=b;`：从C/C++语法级别看，这是一条原子级别的语句；但从编译器得到的汇编指令来看，由于目前计算机CPU架构体系的限制，数据不能直接从内存某处搬运到内存另外一处，必须借助寄存器中转。因此这条语句一般对应链条计算机指令，即将变量b的值搬运到某个寄存器，再从该寄存器搬运到变量a的内存地址中。

既然是两条指令，那么多个线程在执行这两条指令时，某个线程可能会在第一条指令执行完毕后被剥夺CPU时间片，切换到另一个线程而出现不确定的情况。

**解决方法：**C++11新标准提供了对整型变量原子操作的相关库，即`std::atomic`。

模板类型：

```c++
template<class T>
struct atomic;
//传入具体的整型类型对模板进行实例化
//初始化
std::atomic<int> value;
value=99;

//初始化2
//下面代码无法在Linux平台上无法编译通过(指在gcc编译器)
std::atomic<int> value=99;
/*
出错原因：这行代码调用过的是std::atomic的拷贝构造函数
而根据C++11语言规范，std::atomic拷贝构造函数调用=delete标记禁止编译器自动生成
g++在这条规则上遵循了C++11语言规范
*/
```

