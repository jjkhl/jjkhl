# 软件生命周期模型

* 大爆炸模型：简单；质量无法保证
* 边写边改模型：快速得到可运行的版本；计划缺乏，导致版本前后变化较大
* 瀑布模式：计划周密，按部就班；难做到快速开发；构思、分析、设计、开发、测试、最终产品。
* 螺旋模式：开始不必考虑完全，随着计划推进

# 软件测试的分类

* 黑盒测试：也叫功能性测试或行为测试，只看输入输出，不看软件如何运行。
  * 优点：从用户角度触发，不必了解软件实现细节，软件内部实现机制改变后不必修改用例
  * 缺点：无法保证软件内各主要路径被覆盖全，容易导致测试不完全
* 白盒测试：也叫透明性测试，可以看到软件运行但无法做到客观测试。
  * 优点：针对软件代码和路径测试，易于调试，容易发现BUG原因
  * 缺点：要求高，软件实现代码改变，测试用例也需要改变

* 功能测试
* 兼容性测试
* 性能测试
* 安全测试
* 压力测试

# 软件测试方法

* 动态黑盒：
  * 等价类划分：基础的黑盒测试方法。完全根据说明书设计用例，输入条件的一个子集合，该输入集合中的数据对于揭示程序中的错误是等价的。从每一个子集中选取少数具有代表性的数据，从而生成测试用例。
  * 边界值分析法：最大值和最小值测试
* 动态白盒：
* 因果图法：常用黑盒测试，是一种简化的逻辑图。能直观表明输入和输出之间的因果关系，适合检查程序输入条件的各种组合情况。
* 场景法：

# [单元、集成、系统、验收、回归](https://blog.csdn.net/m0_57315623/article/details/125624839)

* 单元测试：完成最小的软件设计单元的验证工作，通常为白盒。
* 集成测试：把通过单元测试的模块集成测试，构造一个在设计中所述的程序结构，通常为灰盒。
* 系统测试：基于系统整体需求说明书的黑盒测试，不分模块。
* 回归测试：版本上线后，对业务主流程进行回归，看在真是环境下是否有问题
* 验收测试：向甲方展示该软件系统满足其需求。

# 测试模型

![image-20220902220941122](picture/V模型.png)

V模型的价值在于它非常明确地标明了测试过程中存在的不同级别，并且清楚地描述了这些测试阶段和开发过程期间各阶段的对应关系。局限性：把测试作为编码之后的最后一个活动，需求分析等前期产生的错误直到后期的验收测试才能发现。



![image-20220902221324395](picture/W模型.png)

W模型是V模型的发展，强调的是测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、功能和设计同样要测试。测试与开发是同步进行的，从而有利于尽早地发现问题。 			

W模型也有局限性。W模型和V模型都把软件的开发视为需求、设计、编码等一系列串行的活动，无法支持迭代、自发性以及变更调整。 			

W模型也有局限性。W模型和V模型都把软件的开发视为需求、设计、编码等一系列串行的活动，无法支持迭代、自发性以及变更调整。 			

![image-20220902221455634](picture/X模型.png)

X模型的左边描述的是针对单独程序片段所进行的相互分离的编码和测试，此后将进行频繁的交接，通过集成最终成为可执行的程序，然后再对这些可执行程序进行测试。

![image-20220902224859783](picture/image-20220902224859783.png)
